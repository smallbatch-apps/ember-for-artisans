
-# A Simple app Extra Credit

As far as we're concerned, the job is done for the requirements given at the start. This was never intended to be a fully complete application, and a lot of functionality was always intended to be removed to simplify things. Nevertheless, we can take things a few more steps towards completion, and learn some handy stuff.

Of particular interest is two bits of refactoring. We can add some persistence, meaning that we save our data. Typically this is to an API of some kind, but it doesn't have to be, and in this case it won't be. The other thing we're wanting to do is to implement components.

Most JavaScript frameworks are based nearly completely on components. Their routers essentially choose which "parent component" to use. The component in those cases is the sort of first order object, the base building block. In Ember they're secondary, with the Route object forming the central object type for the application's structure. That being said, components **are** hugely important for Ember, and it's absolutely best-practice to use them liberally.

# Using Components

Our routes and templates for todo items are a bit messy. Let's be honest, no one is going to use a todo list like this. They're going to want editing to be in-place. They're not going to ever want to go to the "page" for an item. And we have todo-related stuff scattered through several routes. It would be nice to be able to move that stuff out and make it all neater. Components allow us to do that, making self-contained elements. Components can be as small as a button, or as large as a whole form.

Components are something I struggled to "get" for a long time. The best way to think of them is as a custom HTML element. There is a lot of behaviour in a HTML element such as a text input. It needs to support placeholders, that are grey and vanish if your type something else. They need to support things like max size, rejecting new input, handle options such as pattern. The browser does all this without your help. But they're necessarily generic. Components let you make html-like-elements that are specific to your application.

T> For the record, you've actually already used components. The Link-to helper is actually a component for dealing with links, and the Font Awesome add-on gives us the `{{fa-icon}}` component. 

Components can exist in two forms, block and inline. A block component is denoted by a hash, and wraps content. As just mentioned, the link-to helper is a component, and it actually has an inline form as well, in this form it takes the link text as its second (not third) argument, with the actual route as third. `{{link-to "About Us" "about"}}`

## Creating a component

Ember Components **must** be written to a specific naming convention, including a hyphen. So `todo` is not a valid component name, but `todo-item` is. This is mostly it's so that it's consistent with the upcoming Custom Elements spec. Once that is implemented, standardized and supported, Ember's own components can begin to be phased out.

We can go ahead and make a component the expected way: `ember g component todo-item`.

That will make two main files. It will create the `app/components/todo-item.js` and `app/templates/components/todo-item.hbs`. The hbs file is obviously the template, while the js file contains primarily any actions and properties of the component.

## Component templates

Let's start playing around with the template first. The first thing you're going to see (because it's the only thing here) is the `{{yield}}` helper. In the case of block components, `{{yield}}` will display the content placed between the blocks. Our component won't have a block usage, though, so feel free to delete that.

We're going to be replacing out the list item that contains the todo, so grab the contents of the list item in `app/templates/todo.hbs` and paste it right into our component template at `app/components/todo-item.hbs`. You don't need the actual li tag, just its contents, we'll deal with the li tag later.

W> Make sure you delete the `{{if item.checked "...` section as well. Note that there's a trailing `">`` on the end of that. 

## Embedding the component

Using your new component is easy. Insert it as `{{todo-item}}`. The point of a component is that it shouldn't "know" anything. Like a HTML element, it has few real properties of its own, and all of its knowledge needs to be passed in when you use it. If you think about an `<input>`, it needs to be passed type, name, value, placeholder, etc. There are quite a few options we want on this one, so let's start passing stuff in. For a start, we need the actual item in there, from the model. So any sort of state or setting or data needs to be passed through, in this case `item=item`.

T> Note that this isn't considered best-practice. Just as you wouldn't pass the entire user to a text input, you would pass just the actual name, for good components you should be doing the same. In this case, for example, a todo-item becomes highly specific. It will only work with items, nothing else. We're ok with this, but it deserves to be mentioned.

## Replacing the list items

Each component makes itself an HTML element when its embedded. By default it will be a div, but that's not what we want. What we actually want each element to be is the `li` that made up the item previously, and we can do that using the tagName attribute to set it as an `li`, and we will also set the class to what we actually had for bootstrap to style it. The total component embedding should be this in the each loop for `todos.hbs`.

~~~~~~~~
<ul class="list-group">
{{#each model as |item|}}
	{{todo-item item=item tagName="li" class="list-group-item"}}
{{/each}
</ul>
~~~~~~~~

T> Future versions of Ember will support angle bracket components, like `<todo-item>`, sticking even closer to the Custom Elements spec.

If you go back to the browser you'll see that the interface still **looks** largely right, but we've broken it a bit. In particular, the edit link is still a link. We don't really want to go to that. We're going to want there wo be two different "states" for the item, normal, and edit mode. We'll do that by creating a simple boolean property on the component JavaScript at `app/components/todo-item.js`.

~~~~~~~~
export default Ember.Component.extend({
 isEditing: false
});
~~~~~~~~

Go back into the component's template and we can modify the content to add an if condition. Grab the HTML from the `app/todo/edit.hbs` template and paste it into the `if` block, while the list item content stays in the else.

~~~~~~~~
{{#if isEditing}}
	<!-- edit form goes here -->
	<!-- formerly in app/templates/todo/edit.hbs -->
{{else}}
   <!-- list item content goes here -->
   <!-- formerly in app/templates/todos.hbs -->
{{/if}}
~~~~~~~~

Again, that should still **look** about right, because the default view is the show view anyway, not the editing view. If you change the `isEditing` property manually in the JavaScript file you'll see that the edit form comes up. What we need to be able to do is change that from clicking the edit icon. You'll see the item in question in the bottom of our component template. You currently have a link-to wrapping it, but that's not what we want. We just want to put an action on it. We want to tell it to do something when we click on it.

There are a couple of ways we can handle this, but we'll do it by putting an action call on the div that wraps the icon. So in that all we need to do is write `{{action "enableEditing"}}` and the icon will now function as an action. 

~~~~~~~~
<div class="pull-right edit-link" {{action "enableEditing"}}>{{fa-icon "pencil"}}</div>
~~~~~~~~

We'll need to make that action, and we can do so directly in the component JS. All it needs to do is set `isEditing` to true. While we're there, it makes sense to make a second one that simply does the opposite. We're going to need that sooner rather than later.

~~~~~~~~
export default Ember.Component.extend({
 isEditing: false,
 actions: {
 	enableEditing(){
 		this.set('isEditing', true);
 	},
 	disableEditing(){
 		this.set('isEditing', false);
 	}
 }
});
~~~~~~~~

T> It may seem more logical to say `this.isEditing = true;` but Ember need to make sure all of the watchers can watch, and everything stays in sync. Additionally we could make a generic toggleEditing method that swaps the value back and forth, but being explicit here is a little easier to follow, and makes our code a little easier to write.

Clicking on our edit button should now give us a form, and the addition of a cancel button or X with the disableEditing action will let us return to our default.

## Handling the save functionality

We still need to handle the actual update function, but that's easy, just move it over from the `app/controllers/todo/edit.js` into `app/controllers/todo.js` controller and it should be fine. In fact you can now delete both that route and the controller once you nab its action. We also need to make sure we remove the entry from the router. It's worth noting that we're consolidating down a lot of flexibility here, which should really clean up our code. The `app/controllers/todo.js` file will contain nearly all of our functionality.

If you try to actually run this code it will simply do nothing. No error. Our controller has the action, but our component doesn't register it. The issue here is that the component creates its own context. It's triggering the updateItem action **inside the component**, but that doesn't exist, so it blocks the passage of the action. Our component todo-item javascript still needs to handle the action, even if that is just to pass the action through to the route. Components by their nature need to be passed in anything they need access to, but they also need to pass any action or event back out.

The easiest way to do that is to add another simple action in our component javscript, alongside enable and disable of editing. The code is this. We've changed the names of the functions to make it a bit more consistent. 

~~~~~~~~
	updateItem(item) {
		this.set('isEditing', false);
		this.sendAction('action', item);
	}
~~~~~~~~

As well as flicking along the action up the chain until it reaches the route where our code is, we set the `isEditing` flag to false again to close the form.

There is another change we need to do in order to make this work, which is that we need to tell the component what the default action is, the one that we'll be passing along. In this case, it's our updateItem. Our invocation of the todo-item component will look like this.

~~~~~~~~
	{{todo-item item=item tagName="li" class="list-group-item" action="updateItem"}}
~~~~~~~~

## Creating A New Item - Component

We'll make another new component, specifically to handle the "new" interface. 

~~~~~~~~
ember generate component todo-new
~~~~~~~~

The process again is much the same. Grab chunks of interface and stuff them into the component templates. Grab actions and stuff them into the component object. Add a property to set the scope and we're done.

We'll keep the same `isEditing` term, though it's not the best term in this creation context. It just means we can copy and paste the exact same code for both our property and the actions.

## Using the store in a Component

As said earlier, components are intended to be self-contained isolated. This means that unlike Routes and Controllers, which have it super-available, components don't actually have access to the store. Though it **can** be injected in, there's a reason it's not available. If you think of your component as much like a HTML element, it would make no sense for an input tag, or a table tag, to know how to save data.

This is why these actions all belong on our controller.

## Setting up the todo-new component

The todo-new component is a very simple one. It has the same principles as earlier, showing a form only if in editing mode. Its action function lives on the route. 

~~~~~~~~
export default Ember.Component.extend({
 isEditing: false,
 actions: {
 	enableEditing(){
 		this.set('isEditing', true);
 	},
 	disableEditing(){
 		this.set('isEditing', false);
 	}
 }
});
~~~~~~~~

T> This is a perfect candidate for a mixin, which would allow everything following this "isEditing" pattern to share code. There would also be potentially a few other options for refactors, some of which would mean using no code at all. We're trying to keep things nice and explicit here, however.

The implementation of the template is pretty simple, with this block now in `app/templates/todo.hbs`. 

~~~~~~~~
<ul class="list-group">
{{#each model as |item|}}
	{{todo-item item=item tagName="li" class="list-group-item" action="updateItem"}}
{{/each}
{{todo-new tagName="li" class="list-group-item" action="createItem"}}
</ul>
~~~~~~~~

We'll also take the code from `app/controllers/todo/new.js` create action and make a createItem in the `app/controllers/todo.js` route code. Change the create action to a createItem action. The only change you should need to make is the model collection. It's no longer from a parent route, it's now from right here. You can just use `this.get('model')`, instead of `this.modelFor('todo')`.

The `app/controllers/todo.js` file should now contain a moderate amount of quite clear code, consisting of an object full of useful action functions. It should look more or less like this.

~~~~~~~~
export default Ember.Controller.extend({
	actions: {
		updateItem(item){
			alert('item updated');
		},
		createItem(item){
            this.get('model').pushObject({
                id: collection.length,
                text: item.text,
                checked: false
            });
			alert('item created');
        }
	}
});
~~~~~~~~

We're not quite done with this yet. A component needs to have data passed into it. We passed in an item to the todo-item component, and that was fine. The item previously we generated as the model hook from the route. But now there's no route for this element anymore. We need some place to put the `item` object. The obvious place is in the component itself. We can put an arbitrary element on there, and that can just give it a start.

In this case, we end up with our complete component `todo-new.js` file looking like this.

~~~~~~~~
export default Ember.Component.extend({
    isEditing: false,
    actions: {
        enableEditing(){
            this.set('isEditing', true);
        },
        disableEditing(){
            this.set('isEditing', false);
        },
        createItem(item){
            this.set('isEditing', false);
            this.set('item', {});
            this.sendAction('action', item);
        }
    }
});
~~~~~~~~

This does much the same as the previous updateItem code, just cleaning up a little and then passing on the action for the route to handle. In this case we want to do a little more cleaning than before. When a user clicks the save button we want to stop it being in edit mode, but we also don't want it to have the old text in the fields. We set the item again, back to an empty array again.

You'll notice that all of the code in the `routes/todo/new.js` file isn't particularly relevant. That's not a route anyone can or will go to now. You can happily delete it. In fact you can delete that whole directory, as well as the `app/templates/todo/` directory. Don't forget to delete the auto-generated unit tests! Note that you can actually run `ember destroy route todo/edit`, etc, and it will do all of this for you, including deleting no-longer-needed route, clearing the unnecessary tests, and stripping out the router. It should go without saying that this command should be used carefully.

We've been able to remove a substantial amount of code, simplifying our interface substantially. We now have dedicated components for specific behaviours, and most importantly a better, and more useable system.

# Persisting our data

The main feature missing from this app is persistence, the ability to save the data back to something. So that's the first thing we'll tackle in these bonus lessons. 

## Ember Data Models

Persisting data is primarily done in Ember using an add-on called Ember Data. Ember Data looks (and functions) a great deal like Eloquent does in Laravel. That is to say it abstracts the data handling, and provides a way of defining models and the relationships between them to make data access more consistent and simpler.

Ember Data is built into Ember CLI, so you don't need to install it to use it. Like everything else in Ember we can generate an Ember Data model easily. Just run `ember g model todo`, and the model class will be put into the `app/models/` directory. Open that up and you'll see the basic boilerplate for a model.

By itself that won't do much. We need to define a little bit more structure to make it helpful, and that comes down to essentially replicating the structure we had in our model hook in the todo route. 

~~~~~~~~
export default DS.Model.extend({
	text: DS.attr('string'),
	checked: DS.attr('boolean', {defaultValue: false})
});
~~~~~~~~

Note the id is not in there. Ember Data knows what that is, and handles it internally. Unlike Eloquent, though, you do need to explicitly state the fields.

Ember Data is also where you would handle any relationships between models, such as a Post model might have `comments: DS.hasMany('comment')`.

The namespace here is DS, rather than the more typical Ember. DS stands for "data store", Ember's in-memory collection of models. This is a service widely available in Ember routes and controllers.

The type here is optional, and often omitted especially for its default of strings. The object with `defaultValue` is even more often omitted, but sometimes both are handy to make it clear exactly what is intended. In this case we want our tasks to always be false from the start.

T> If you know in advance what you want in an Ember Data model, you can actually add them in the generation command. `ember g model todo text:string checked:boolean:false`.

## Adapters

Adapters tell Ember Data what the rules are for reading the model's actual persisted form. Is it a RESTful API? Some sort of SOAP call? A backend-as-a-service like Firebase? An S3 instance?

As much as possible we do **not** care about this, we just want to know that when we call `model.find(12)` our model will be sent back from the server. All the rules and implementation details live in the adapter.

Adapters sound hard to set up, but they're not. Common standards - such as Rails Active Record or REST - have standard addons that work right up. In fact, if you set **no** adapter it uses something very like REST by default, which is the JSON-API spec.

We don't want to use REST though. We don't want to set up a whole API. We want to store this locally, so we want to use the localStorage adapter.

First of all, we need an adapter for the model. Ember can take a different adapter for each model, so your user data could be on a REST API, while some order info lives in Firebase. Totally fine, and relationships between them can still be maintained. Ember Data is one of Ember's real killer features. 

We can make an adapter exactly as you would expect by now. You just need to specify what model you want to make an adapter for. 

~~~~~~~~
ember generate adapter todo
~~~~~~~~

T> You can actually create an adapter called "application", which will then be all models unless overriden by a specific one. We could have used application here, but wanted it to be more clear what exactly the model and adaptor are doing and how they relate.

Now all we need to do is install the LocalStorage adapter.

~~~~~~~~
ember install ember-localstorage-adapter
~~~~~~~~

Kill and restart the ember server and you'll have a working model that uses the browser's LocalStorage for persistence. If you go to `app/adapters` (a new directory) and open the `todo.js` file you'll see that it's much like most of the modules your generators build. In this case we have to change a little more than usual. Ember generated a generic "application" adaptor, not a LocalStorage adapter, so we need to update the code to the following

~~~~~~~~
import LSAdapter from 'ember-localstorage-adapter';

export default LSAdapter.extend({
  namespace: 'todo-app'
});
~~~~~~~~

## Serializers

Where the adapter handles how to read the data, serializers handle how to write it. Most often serializers are simple things, just passing through whatever they're sent, but in cases with complex rules or specific requirements they're the place you want to implement those, converting your `firstName` field to the API's required `FIELD_FIRST_NAME` or whatever.

Serializers are generated the same way as adapters, enough so that I'm not actually going to give the command to do it.

The code generated will again need to be updated to make it a LocalStorage serializer rather than the generic.

~~~~~~~~
import LSSerializer from 'ember-localstorage-adapter';

export default LSSerializer.extend({
  namespace: 'todo-app'
});
~~~~~~~~

## Using Ember Data in our Todo Route

Using Ember Data models in a route is super easy. All we have to do is replace out the contents of the model hook with fancy Ember Data calls. Ember Data collections have some special functions on them to make finding and filtering data easy. The simplest is just to return the whole lot, which is what we actually want anyway.

~~~~~~~~
model() {
	return this.get('store').findAll('todo');
}
~~~~~~~~

This just finds all the todo items which are valid ember models. This means it gets data from the server (or in this case, local storage pretending to be a server) and returns that.

Initially no data will be returned, as we haven't made any todo items yet, and we killed our pasted in test ones. Worth mentioning that none of the rest of our code handling these items needs to change. It was always nicely isolated.

T> We don't have our show route for a single todo item any more, but if we did it would have this in its model hook: `return this.store.findRecord('todo', id);`.

## Creating Items

With no items to edit or display, there's really not a lot here worth seeing. The first thing to do is to update the `app/controllers/todo.js` controller actions in a few places. We need it to do more than just add to the collection, because that's just the stuff Ember is aware of, not the data that's actually on the server. We also need to change the createItem object to make it an Ember Data model.

We'll do that first, and it's only a small code change.

~~~~~~~~
model(){ 
	return store.createRecord('todo', {
  		text: '',
  		checked: false
	});
}
~~~~~~~~

This new model is created and added to the store, but it's not saved to anything yet. We handle that in the action. Because our model is actually a proper Ember Data model, the process here becomes quite a bit simpler.

~~~~~~~~
actions: {
	create(model){
		this.store.pushObject(model);
		model.save();
	}
}
~~~~~~~~

## Handling updates

The updating of data is not much different to how it is now. The only difference is that we no longer have an edit route, so we can't put the action on the edit route. We can put it on the todo route, though. So let's move that entirely as-is.

The action we have doesn't do a lot. All it does is show an alert, which is fine when messing around with test data, but not exactly ideal with persistent data. We need to persist any changes we make. Thankfully that's trivial.

~~~~~~~~
actions: {
	update(item){
		item.save();
		alert('saved');
	}
}
~~~~~~~~

You'll probably be noticing at this point how little code is needed here. `item.save()` is a crazy small amount of code to write to persist our data. It should be noticed that this code would **not change** if we were writing back to a Laravel server, or anything else. This code doesn't have to know or care how it's persisted or where. The details of **how** to save are handled in Ember Data, in particular in that localStorage adapter and serializer we added in before.

## Updating our checking

There's very little to do here. Again, nothing much needs to change except to persist the existing updates. The action for this is already on the todo route - it is a feature of the list, after all. So we don't have to move it.

~~~~~~~~
actions: {
	checkItem(item){
	  Ember.set(item, 'checked', !Ember.get(item, 'checked'));
	}
}
~~~~~~~~

