
-# A Simple app Extra Credit

As far as we're concerned, the job is done for the requirements given at the start. This was never intended to be a fully complete application, and a lot of functionality was always intended to be removed to simplify things. Nevertheless, we can take things a few more steps towards completion, and learn some handy stuff.

# Persisting our data

The main feature missing from this app is persistence, the ability to save the data back to something. So that's the first thing we'll tackle in these bonus lessons. 

## Ember Data Models

Persisting data is primarily done in Ember using an add on called Ember Data. Ember data looks (and functions) a great deal like Eloquent does in Laravel. That is to say it abstracts the data handling, and provides a way of defining models and the relationships between them, but it is not at all an ORM.

Ember Data is built into Ember CLI, so you don't need to install it to use it. Like everything else in Ember we can generate a model easily. Just run `ember generate model todo`, and the model class will be put into the `app/models/` directory. Open that up and you'll see the basic boilerplate for a model.

By itself that won't do much. We need to define a little bit more structure to make it helpful, and that comes down to essentially replicating the structure we had in our model hook in the todo route. 

~~~~~~~~
export default DS.Model.extend({
	text: DS.attr('string'),
	checked: DS.attr('boolean', {defaultValue: false})
});
~~~~~~~~

Note the id is not in there. Ember Data knows what that is, and handles it internally.

Ember Data is also where you would handle any relationships between models, such as a Post model might have `comments: DS.hasMany('comment')`.

The namespace here is DS, rather than the more typical Ember. DS stands for "data store", Ember's in-memory collection of models. This is a singleton service, widely available in Ember routes and controllers.

The type here is optional, and often omitted. The object with `defaultValue` is even more often omitted, but sometimes both are handy to make it clear exactly what is intended.

## Adapters

Adapters tell Ember Data what the rules are for reading the model's actual persisted form. Is it a RESTful API? Some sort of SOAP call? A backend-as-a-service like Firebase? An S3 instance?

As much as possible we do **not** care about this, we just want to know that when we call `model.find()` our model will be sent back from the server. All the rules and implementation details live in the adaptor.

Adapters sound hard to set up, but they're not. Common setups - such as Rails Active Record or REST - have standard addons that work right up. In fact, if you set **no** adapter it uses REST by default.

We don't want to use REST though. We don't want to set up a whole API. No, we want to store this locally. We want to use the localStorage adapter.

First of all, we need an adapter for the model. Ember can take a different adapter for each model, so your user data could be on a REST API, while some order info lives in Firebase. Totally fine, and relationships between them can still be maintained. Ember Data is one of Ember's real killer features. 

We can make an adapter exactly as you would expect by now. You just need to specify what model you want to make an adapter for. 

~~~~~~~~
ember generate adapter todo
~~~~~~~~

T> You can actually create an adapter called "application", which will then be all models unless overriden by a specific one. We could have used application here, but wanted it to be more clear what exactly the model and adaptor doing.

Now all we need to do is install the LocalStorage adapter.

~~~~~~~~
ember install ember-localstorage-adapter
~~~~~~~~

Kill and restart the ember server and you'll have a working model that uses the browser's LocalStorage for persistence. If you go to `app/adapters` (a new directory) and open the `todo.js` file you'll see that it's much like most of the modules your generators build. In this case we have to change a little more than usual. Ember generated a generic "application" adaptor, not a LocalStorage adapter, so we need to update the code to the following

~~~~~~~~
import LSAdapter from 'ember-localstorage-adapter';

export default LSAdapter.extend({
  namespace: 'todo-app'
});
~~~~~~~~

## Serializers

Where the adapter handles how to read the data, serializers handle how to write it. Most often serializers are simple things, just passing through whatever they're sent, but in cases with complex rules or specific requirements they're the place you want to implement those, converting your `firstName` field to the API's required `FIELD_FIRST_NAME` or whatever.

Serializers are generated the same way as adapters, enough so that I'm not actually going to give the command to do it.

The code generated will again need to be updated to make it a LocalStorage serializer rather than the generic.

~~~~~~~~
import { LSSerializer } from 'ember-localstorage-adapter';

export default LSSerializer.extend({
  namespace: 'todo-app'
});
~~~~~~~~

## Using Ember Data in our Todo Route

Using Ember Data models in a route is super easy. All we have to do is replace out the contents of the model hook with fancy Ember Data calls. Ember Data collections have some special functions on them to make finding and filtering data easy. The simplest is just to return the whole lot, which is what we actually want anyway.

~~~~~~~~
model() {
	return this.store.findAll('todo');
}
~~~~~~~~

This just finds all the todo items which are valid ember models. This means it gets data from the server (or in this case, local storage pretending to be a server) and returns that.

Initially no data will be returned, as we haven't made any todo items yet, and we killed our pasted in test ones.

T> We aren't going to keep our show route for a single todo item for long, but if we did it would have this in its model hook: `return this.store.findRecord('todo', todo_id);`.

## Creating Items

With no items to edit or display, there's really not a lot here worth seeing. The first thing to do is to update the `app/routes/todo/new.js` route action and model. We need it to do more than just add to the collection, because that's just the stuff Ember is aware of, not the data that's actually on the server. We also need to change the model to make it an Ember Data model.

We'll do that first, and it's only a small code change.

~~~~~~~~
model(){ 
	return store.createRecord('todo', {
  		text: '',
  		checked: false
	});
}
~~~~~~~~

This new model is created and added to the store, but it's not saved to anything yet. We handle that in the action. Because our model is actually a proper Ember Data model, the process here becomes quite a bit simpler.

~~~~~~~~
actions: {
	create(model){
		this.store.pushObject(model);
		
		model.save();
	}
}
~~~~~~~~

## Handling updates

The updating of data is not much different to how it is now. The only difference is that we no longer have an edit route, so we can't put the action on the edit route. We can put it on the todo route, though. So let's move that entirely as-is.

The action we have doesn't do a lot. All it does is show an alert, which is fine when messing around with test data, but not exactly ideal with persistent data. We need to persist any changes we make. Thankfully that's trivial.

~~~~~~~~
actions: {
	update(item){
		item.save();
		alert('saved');
	}
}
~~~~~~~~

You'll probably be noticing at this point how little code is needed here. `item.save()` is a crazy small amount of code to write to persist our data. It should be noticed that this code would **not change** if we were writing back to a Laravel server, or anything else. This code doesn't have to know or care how it's persisted or where. The details of **how** to save are handled in Ember Data, in particular in that localStorage adapter and serializer we added in before.

## Updating our checking

There's very little to do here. Again, nothing much needs to change except to persist the existing updates. The action for this is already on the todo route - it is a feature of the list, after all. So we don't have to move it.

~~~~~~~~
actions: {
	checkItem(item){
	  Ember.set(item, 'checked', !Ember.get(item, 'checked'));
	}
}







# Using Components

Our routes and templates for todo items are a bit messy. Let's be honest, no one is going to use a todo list like this. They're going to want editing to be in-place. They're not going to ever want to go to the page for an item. And we have todo-related stuff scattered through several routes. It would be nice to be able to move that stuff out and make it all neat. Components allow us to do that, making self-contained elements. Components can be as small as a button, or as large as a whole form.

T> For the record, you've actually already used components. The Link-to helper is actually a component for dealing with links, and the Font Awesome add on gives us the `{{fa-icon}}` component. 

## Creating a component

Components **must** be written to a specific naming convention, including a hyphen. So `todo` is not a valid component name, but `todo-item` is. This is to make sure it doesn't conflict with existing HTML elements, and is also consistent with the upcoming Custom Elements spec.

We can go ahead and make a component the expected way: `ember generate component todo-item`.

That will make two main files. It will create the `app/components/todo-item.js` and `app/templates/components/todo-item.hbs`. The hbs file is obviously the template, while the js file contains primarily any actions and properties of the component.

## Component templates

Let's start playing around with the template first. We're going to be replacing out the list item that contains the todo, so grab the contents of that and paste it right into our component template at `app/components/todo-item.hbs`. You don't need the actual li tag, just its contents, we'll deal with the li tag later.

## Embedding the component

Using your new component is easy. Insert it with `{{todo-item}}`. The point of a component is that it shouldn't "know" anything. Like a HTML element, it has no real properties of its own, and all of its knowledge needs to be passed in when you use it. There are quite a few more options we want on this one, so let's start passing stuff in. For a start, we need the actual item in there, from the model. So any sort of state or setting or data needs to be passed through, in this case `item=item`.

Each component is itself an HTML element. By default it will be a div, but that's not what we want. What we actually want each element to be is the `li` that makes up an item, and we can do that using the tagName attribute to set it as an `li`, and we will also set the class to what we actually had for bootstrap to style it. The total component embedding should be this.

~~~~~~~~
{{todo-item item=item tagName="li" class="list-group-item"}}
~~~~~~~~

T> Future versions of Ember will support angle bracket components, like `<todo-item>`, sticking even closer to the Custom Elements spec.

If you go back to the browser you'll see that the interface still **looks** largely right, but we've broken it a bit. In particular, the edit link is still a link. We don't really want to go to that. We're going to want there wo be two different "states" for the item, normal, and edit mode. We'll do that by creating a simple boolean property on the component JavaScript.

~~~~~~~~
export default Ember.Component.extend({
 isEditing: false
});
~~~~~~~~

Go back into the component's template and we can modify the content to add an if condition. Grab the HTML from the `app/todo/edit.hbs` template and paste it into the `if` block, while the list item content stays in the else.

~~~~~~~~
{{#if isEditing}}
	<!-- edit form goes here -->
{{else}}
   <!-- list item content goes here -->
{{/if}}
~~~~~~~~

Again, that should still **look** about right, because the default view is the show view anyway, not the editing view. If you change the isEditing property manually (in the `todo-item.js` file) you'll see that the edit form comes up. What we need to be able to do is change that from clicking the edit icon. 

Find that thing and edit it. You currently have a link-to wrapping it, but that's not what we want. We just want to put an action on it. There are a couple of ways we can handle this, but we'll do it by putting an action call on a div we'll add that wraps the icon. So in that all we need to do is write `{{action "enableEditing"}}` and the icon will now function as an action. 

~~~~~~~~
<div{{action "enableEditing"}}>{{fa-icon "pencil" class="pull-right edit-link"}}</div>
~~~~~~~~

That action won't do anything yet, because there's nothing on the component to handle it or any other action. We'll need to make that action, and we can do so directly in the component JS. All it needs to do is set `isEditing` to true. While we're there, it makes sense to make a second one that simply does the opposite. We're going to need that sooner rather than later.

~~~~~~~~
export default Ember.Component.extend({
 isEditing: false,
 actions {
 	enableEditing(){
 		this.set('isEditing', true);
 	},
 	disableEditing(){
 		this.set('isEditing', false);
 	}
 }
});
~~~~~~~~

T> It may seem more logical to say `this.isEditing = true;` but Ember need to make sure all of the watchers can watch, and everything stays in sync.

Clicking on our edit button should now give us a form, and the addition of a cancel button or X with the disableEditing action will let us return to our default.

## Using the store in a Component

As said earlier, components are intended to be self-contained and isolated. This means that unlike Routes, which have it super-available, components don't actually have access to the store. They can get it, but they need to get it as a service. Conveniently, the store is already registered as a service, ready to inject. 

Doing this is trivially easy. You need to add a parameter called `store` into your component js. We'll use the new todo component for this, at `app/components/todo.js`, you can see we have the actions for creating and saving, and a basic blank model. We want to change both of these. Add a `store` property of `store: Ember.inject.service('store')`. This component now has access to the store, as an injected service.

T> You don't actually have to have that `'store'` in there. That argument is the name of the service you wish to inject, but if you are calling a property with the same name as the service it will just assume that. `store: Ember.inject.service()` will be identical and preferred.

Your component can get hold of the store to actually do things with it by using `this.get('store')`. Note the difference between the route's syntax of `this.store` and the component's syntax of `this.get('store')`.

W> This isn't exactly best practise. A component shouldn't really have access to the store. What we should be doing is running actions on a controller
