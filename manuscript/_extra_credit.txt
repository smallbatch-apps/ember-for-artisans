# Extra Credit

As far as we're concerned, the job is done for the requirements given at the start. This was never intended to be a fully complete application, and a lot of functionality was always intended to be removed to simplify things. Nevertheless, we can take things a few more steps towards completion, and learn some handy stuff.

## Using Components

Our routes and templates for todo items are a bit messy. Let's be honest, no one is going to use a todo list like this. They're going to want editing to be in-place. They're not going to ever want to go to the page for an item. And we have todo-related stuff scattered through several routes. It would be nice to be able to move that stuff out and make it all neat. Components allow us to do that, making self-contained elements. Components can be as small as a button, or as large as a whole form.

T> For the record, you've actually already used components. The Link-to helper is actually a component for dealing with links, and the Font Awesome add on gives us the `{{fa-icon}}` component. 

Components **must** be written to a specific naming convention, including a hyphen. So `todo` is not a valid component name, but `todo-item` is. This is to make sure it doesn't conflict with existing HTML elements, and is also consistent with the upcoming Custom Elements spec.

We can go ahead and make a component the expected way: `ember generate component todo-item`.

That will make two main files, both of which are in the `app/components/` directory. They are `todo-item.js` and `todo-item.hbs`. The hbs file obviously is the interface and template, while the js file contains primarily any actions and properties of the component.


Let's start playing around with the template first. We're going to be replacing out the list item that contains the todo, so grab the contents of that and paste it right into our component template at `app/components/todo-item.hbs`. You don't need the actual li tag, just its contents, we'll deal with the li tag later.

Using your new component is easy. Insert it with `{{todo-item}}`. There are quite a few more options we want to give it, though, so let's start passing stuff in. For a start, we need the actual item in there, from the model. The component won't have access to it otherwise. Note that the component won't have access to **anything** unless it's actually passed in. So any sort of state or setting or data needs to be passed through, in this case `item=item`.

Each component is itself an HTML element. By default it will be a div, but that's not what we want. What we actually want each element to be is the `li` that makes up an item, and we can do that using the tagName attribute to set it as an `li`, and we will also set the class to what we actually had for bootstrap to style it. The total component embedding should be this.

~~~~~~~~
{{todo-item item=item tagName="li" class="list-group-item"}}
~~~~~~~~

T> Future versions of Ember will support angle bracket components, like `<todo-item>`, sticking even closer to the Custom Elements spec.

If you go back to the browser you'll see that the interface still **looks** largely right, but we've broken it a bit. In particular, the edit link is still a link. We don't really want to go to that. We're going to want there two be two different "states" for the item, normal, and edit mode. We'll do that by creating a simple boolean property on the component JavaScript.

~~~~~~~~
export default Ember.Component.extend({
 isEditing: false
});
~~~~~~~~

Go back into the component's template and we can modify the content to add an if condition. Grab the HTML from the `app/todo/edit.hbs` template and paste it into the `if` block, while the list item content stays in the else.

~~~~~~~~
{{#if isEditing}}
	<!-- edit form goes here -->
{{else}}
   <!-- list item content goes here -->
{{/if}}
~~~~~~~~

Again, that should still **look** about right, because the default view is the show view anyway, not the editing view. If you change the isEditing property manually you'll see that the edit form comes up. What we need to be able to do is change that from clicking the edit icon. Find that thing and edit it. You currently have a link-to wrapping it, but that's not what we want. We just want to put an action on it. There are a couple of ways we can handle this, but we'll do it by putting an action call on the div that wraps the icon. So in that all we need to do is write `{{action "enableEditing"}}` and the icon will now function as an action. We'll need to make that action, and we can do so directly in the component JS. All it needs to do is set `isEditing` to true. While we're there, it makes sense to make a second one that simply does the opposite. We're going to need that sooner rather than later.

~~~~~~~~
export default Ember.Component.extend({
 isEditing: false,
 actions {
 	enableEditing(){
 		this.set('isEditing', true);
 	},
 	disableEditing(){
 		this.set('isEditing', false);
 	}
 }
});
~~~~~~~~

T> It may seem more logical to say `this.isEditing = true;` but Ember need to make sure all of the watchers can watch, and everything stays in sync.

Clicking on our edit button should now give us a form, and the addition of a cancel button or X with the disableEditing action will let us return to our default.

We still need to handle the actual save function, but that's easy, just move it over from the `app/routes/todo/edit.js` route and it should be fine. In fact you can now delete that route once you nab its action. The only thing we need to do now is handle the check. And all that needs to happen for that is to move the check action from the todo route. You'll note that this todo route now has only the create action remaining. So let's move that. We'll make another new component, specifically to handle the "new" interface. 

~~~~~~~~
ember generate component todo-new
~~~~~~~~

The process again is much the same. Grab chunks of interface and stuff them into the component templates. Grab actions and stuff them into the component object. Add a property to set the scope and we're done.

We'll keep the same `isEditing` term, though it's not the best term. That means we can copy and paste the exact same code for both our property and the actions.

T> If we wanted, we could actually make this whole "isEditing" process a _mixin_, much like a trait in PHP. In fact, that's the exact example used in the documentation. That would allow us to re-use the same code without duplication. This is particularly useful for this sort of functionality, because it's likely to be widely used.

Again, we need the template to have the `#if else` logic, this time with the basic button and the form to create a new item. The create action needs to be moved into the component as well.

We need a lot less stuff to make this one work. We don't care about the tag and there's no styling. There's no item to pass in and edit, because we're creating a new one. What we do want is the actual collection of items, though, because we want to add to it.

The code in the create() action is pretty close to what we want.

~~~~~~~~
{{todo-new collection=model}}
~~~~~~~~

You'll notice that all of the code in the `routes/todo/new.js` file isn't particularly relevant. That's not a route anyone can or will go to now. You can happily delete it. In fact you can delete that whole directory, as well as the `app/templates/todo/` directory.

## Persisting our data

The main feature missing from this app is persistence, the ability to save the data back to something. So that's the first thing we'll tackle in these bonus lessons. Persisting data is primarily done in Ember using an add on called Ember Data. Ember data looks (and functions) a great deal like Eloquent does in Laravel. That is to say it abstracts the data handling, and provides a way of defining models and the relationships between them, but it is not at all an ORM.

Ember Data is built into Ember CLI, so you don't need to install it to use it. Like everything else in Ember we can generate a model easily. Just run `ember generate model todo`, and the model class will be put into the `app/models/` directory. Open that up and you'll see the basic boilerplate for a model.

By itself that won't do much. We need to define a little bit more structure to make it helpful, and that comes down to essentially replicating the structure we had in our model hook in the todo route. 

~~~~~~~~
export default DS.Model.extend({
});
~~~~~~~~