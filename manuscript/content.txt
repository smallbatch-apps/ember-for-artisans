
-# Making a simple Ember App

# Making an Ember App

In this chapter we will begin creating a very basic Ember application. It's a stand-alone app, and has no database layer, so Laravel is not a factor here.

This will just be a simple list of ToDo items, so we can take a clean look at a well-known standard app that steps just a little beyond "Hello World" without wandering into complex business requirements or confusing syntax. In some ways this is a bad choice. The true benefits of a framework like Ember (or Laravel for that matter) are only realised with more complicated projects. It's important to bear that in mind with tutorials such as this. In order to be useful as a teaching aid it almost by definition can't be complicated enough to need what's being taught.

## Installing the Ember CLI

Much of Ember is built around (and by) the Ember CLI - a command-line tool that handles building, asset processing, depenency management, and a whole lot of other things.

The first step is to install this. Doing so requires npm, the Node Package Manager. NPM is certain to be installed on almost any environment that a Laravel install is running on, and is definitely installed on any Homestead installation.

## Creating a new app

The process of creating a new Ember application is surprisingly simple. One of the best features of Ember is the ability to get a working project with a high degree of functionality up and running extremely quickly. Ember CLI can do this easily.

   ember new todos-demo

Once NPM finishes installing all the stuff, you will have an ember app that works and is editable. All the directories are created and ready to go.

# Ember CLI

Ember CLI is to Ember what Artisan is to Laravel. It contains a lot of helpful command-line tools that maintain consistency, and makes Ember a simpler and more developer friendly environment. Ember CLI has now become a core feature of Ember, and does a lot of stuff like building, live-reload, serving, generation, etc, all of which eat a chain of dicks in other frameworks. Ember CLI also contains a lot of Ember addons by default.

Ember's CLI isn't just a simple wrapper around something like Yeoman for facilitating new projects, but a comprehensive and powerful tool. People familiar with other frameworks (or JavaScript in general) will know how much of a pain it can be working with the tools to get a project actually up. Linting, minifying, uglifying, concatinating, moving files, Sass/less compiling, transcribing ES6, etc, is all done in something like gulp or webpack. This means setting up tools, checking paths, creating directories, installing dependencies, managing add-ons, and so on. It's not a killer, but... It is a bit of a pain.

Where Ember differs is that the CLI handles all of this for you. Ember CLI does a staggering amount of stuff. It creates new Ember applications. It generates boilerplate. It manages add-ons. It runs full build systems, a server, live reloading, debugging, testing, deployment, and more. There is literally zero setup for most apps. No gulp or grunt files. No configuration.

The other thing Ember CLI provides is a range of generation blueprints. These allow boilerplate to be immediately created, while maintaining consistency of code, and of name. It is highly recommended to use these generators instead of creating the files or directories manually. Otherwise you accidentally spell "adapter" wrong and it takes you two frustrating days of debugging to notice. Or so I'm told.

## Ember Serve

Ember CLI includes a node based server to serve as a development environment for your app. When you type `ember serve` it will run up that server, fully building your application. It will then pop up a message saying how to access the site. Generally this is at http://localhost:8080.

The ember serve command can take a number of parameters, such as manually setting the port, or proxying an API to put off security requirements. Again, this is much like what Laravel offers in `artisan serve`.

## Compiling, concatenating, building, and transpiling with Broccolli

In any modern JavaScript application there are a bunch of things that need to be done pretty regularly. For example, scripts need to be minified, and concatenated into a single file for more efficient downloads. ES20x scripts need to be translated to ES5 for use. Coffeescript needs to be converted. Sass needs to be complied. And so on. Each of these things is kind of a pain, but together they're a real burden for maintenance. This is not a new problem, nor is it one without solutions.

The term used for these is usually something along the lines of a _task runner_. Grunt was a popular solution for a long time, able to run a number of small tasks in sequence through a NodeJS application. Gulp took the same ideas, but made the developer experience a little nicer.

Broccoli is another approach. I'm not actually going to go into a lot of detail on how Broccoli works and how it differs from Gulp, for two simple reasons - I don't know. And I don't care. The benefit of EmberCLI is to isolate me from the tedium of setup required to handle these assets and transformations. And it just does. It's exceptionally fast, and handles all of this nonsense.

## Installing FontAwesome Addons

# Anatomy of an Ember App

The structure of an Ember app is not dissimilar at all to a Laravel equivalent. In both cases the meat of the app is in the /app directory. Both have a /public directory, but in Ember's case that is for assets, which in the Laravel app go into the /resources directory. Ember has a /dist directory, which contains the bundled and working application ready for deployment and distribution. Those files should never be edited, because Ember will overwrite them if you even take a hard glance at the app files.

In both cases there are directories in the app directory that should be the same, or related, such as /app/templates/ and /app/models/. Ember has quite a few different directories, such as routes and adapters that won't have a parallel in Laravel.

## Similar to Laravel - but differences can be tricky

You can see at this point that we're missing something. There is no controller in this equation at all. If comparing to a Laravel application we'd have a whole bunch of errors at this point. This highlights an important behavior of Ember. Convention is not just enforced, but assumed. Wherever possible, rational and sensible defaults are used, and various bits and pieces of boilerplate can just be completely omitted entirely, with Ember filling in the gap itself.

In this example, the missing piece is a Route. If Ember sees a URL that's being called without a Route file, it will automatically fill in the gap with a route with default behavior - pretty much none. If it doesn't find a template, it will similarly dump in a blank one with just an outlet in it. This sort of of thing happens routinely in Ember. Sensible and logical conventions are facilitated.

Controllers in Ember are not what they seem to a Laravel developer. In Emberland a controller is nothing more than a decorator for model data. For example, if your model has a first name and a last name, and you want to add a "full name" then the controller is a fine place to do that. It doesn't really affect the underlying data, just its display. But that central, binding, all important negotiator between data and view that is held by a Controller in Laravel is NOT done by an Ember Controller. That role is filled by a Route. I stress that this is all just terminology. A route in Ember has almost exactly the same job as a Laravel controller. If it seems like I'm over-emphasising this, there's a reason. When I first started using Ember this was one of the things I struggled with the most. I kept wanting to think the Controller was like a Laravel controller. If this seems "wrong", considering the pattern is called MVC, now is a good time to reconsider that the pattern refers to layers of concern, not the name of the classes. Eloquent models in Laravel are NOT the model. They are a part of the model layer. Various repositories might also be included, just as the Controller layer also includes the router and other thing. Calling the classes controller or model is a mere convention. Obviously a reasonable one. But in Ember, both Controllers and Routes fit neatly within that controller layer. Controllers in Ember are being steadily eroded in favour of services, components, and other solutions. Just bear in mind that an Ember Route is the same job as a Laravel Controller and you'll be fine.

## ES6/ES2015

ES2015 is a more up-to-date term for what we used to call ES6, an update to JavaScript which allows new functionality such as better scope management and support for classes. ES2015 allows discrete packets of functionality to be split away, and then all built back together later, exactly as we do with Laravel. Lots of small files with very specific jobs. It's not the intention of this book to teach you everything in ES2015, and it's well worth knowing on its own. But there are two main things you need to know to get along with Ember. First of all, ES2015 files import what they need to use, and export themselves as an object based on their filename. Think includes in PHP, for the first part. The second thing is that pretty much no browser fully or properly supports ES2015. It is invariably compiled down (transpiled) to standard JavaScript using a tool called Babel. Ember CLI handles this process, pulling in and converting all the modules, templates, etc. All Ember apps run as standard JavaScript, even though they're written in fancy new JS syntax.

## Router

The Ember router is recognisably like the Laravel router.

~~~~~~~~
Router.map(function() {
  this.route('about', { path: '/about' });
  this.route('todos', { path: '/todos' });
});
~~~~~~~~

Can clearly be compared with Laravel's equivalent:

~~~~~~~~
Route::get('about', 'HomeController@about');
Route::get('todos', 'TodoController@list');
~~~~~~~~

The similarities are clear, and the initial differences of syntax mostly come down to "because it's Javascript", but there are some important differences. The method specified in Laravel makes no sense in Ember routes, where everything is a GET. Obviously the first argument names the route in both cases. After that, Laravel and Ember diverge. Laravel defines a controller, and the method on that controller. Ember doesn't do this. The resolver doesn't need to be told what router class to use - convention enforces it. They **must** be at `routes/about.js` and `routes/todos.js`.

T> The `path` keys on the Ember routes are not strictly necessary. If the path is the same as the route name it can be completely omitted - another example of Ember using sensible default behaviours. That would make it `this.route('about');`. Much cleaner.

## Routes vs Controllers

One of the biggest differences between Laravel and Ember is in the role of a "Controller". Given that both frameworks are MVC frameworks and the C is "controller", it makes sense that they're both there. In Laravel the Controller is an intermediary between the router and the model, getting model data for the request, and returning it as a response. In Ember, that role is handled by the Route object. The controller is more about decorating the model data for display. Note that this is purely a name difference. The role of the Route is functionally hugely similar to a Laravel controller.

## Templates

Templates in Ember use Handlebars, which is a templating system not dissimilar to Blade. Like Blade it provides a lot of helpers to do things like looping. Much of the syntax is familiar to anyone used to Blade, or for that matter the slightly more fully featured Twig. In a Laravel Blade template, for example

~~~~~~~~
<ul>
@foreach ($todos as $todo)
    <li>{{ $todo->title }}</li>
@endforeach
</ul>
~~~~~~~~

Would be done in Ember as

~~~~~~~~
<ul>
{{#each todos as todo}}
    <li>{{ todo.title }}</li>
{{/each}}
<ul>
~~~~~~~~

Different, but not totally unfamiliar.

In the same way as Blade uses @yield to embed a sub-template, Ember uses {{outlet}}. Note that these are not specified to a a particular sub-template because they're much more dynamic. Ember figures all that out.

## Models

A model backs a route, and the default implementation is an Ember Data model. This is OK because the Ember Data model looks pretty similar to a Laravel Eloquent Model. The App does not need to use Ember Data, though. POJOs are fine.

## Components

A Component in Ember is a reusable self-contained bit of interface. Typically it will be an HTML element, like a form or a button. There really isn't anything comparable to this in Laravel but the principle of them isn't hugely complicated. A component is by nature isolated from the rest of the system. They are embedded directly into a template. Ember components are related to and are intended to mirror Web Components, a HTML standard that is still being implemented. This means they also have to be named according to Web Component standards, specifically with a hyphenated name such as  button-approve or user-row. The goal is that when Web Components become viable, you will be able to simply replace out the Ember Components with them.

The current syntax for Components is as follows

   <ul>
   {{#each model as |item|}}
   {{todo-item item=item}}
   {{/each}}
   </ul>

Future versions of Ember will allow `<todo-item item=item>`, to stick even closer to the Web Component syntax.

Ember development is strongly (and increasingly) based around good use of components, and for good reason.

## Pods

Which is more appropriate? Grouping all your routes and models together by entity type, like user/route.js, user/model.js? Or grouping like files together, such as routes/user.js and routes/projects.js? The answer, of course, is yes. Either of those is entirely reasonable, and completely arbitrary. Laravel typically uses the latter, grouping like files together, but you can always move things around. Ember made a similar decision initially, and CLI defaults to that. But it also supports the former option, grouping entity files together, a form Ember calls "Pods". While the current default (?) is the same as Laravel's, that will be changing. We will do our ToDo app without using pods, but implement them in the second. It really is a trivial difference, and all the generators work fine. You can mix and match styles, or change it at will.

# Building a Todo App

## Generating the first route

## Templates

## Creating

## Deleting

## Checking

-# A more ambitious app

# Introduction

What is the intention, what are we planning to build, how we're going to structure it in two separate apps and work on them independently, etc.

# First, an API

## What is an API?

## Keeping it RESTful

## An established spec - JSON API

# Building an API in Laravel

Thankfully, Laravel is an exceptional tool to build an API in. It supports JSON output natively, and can be rapidly able to supply the app with data.

## Determining resource entities, generating, creating, etc

## Making an API that plays nicely with Ember

# Make Another Ember App

# Ember Data

## Using Adapters

## Connecting to an API

## Proxying an API

## Implementing CORS

# The rest of the book




# Appendix - Greg's stuff

Getting started
Setting up your environment (inc. PHPStorm to use .editorconfig)
Project layout (2 repositories etc)
Finding help
The Ember ecosystem
Model View Controller vs Model Router Component
Nomenclature differences
Responsibilities of each layer
Router first
How the URL is the most important part of Ember
The router state machine
Building a simple todo application
Walk through building a basic client side todo application in the traditional “todomvc” style
Ember data and the API
Common approaches (JSONAPI vs RESTful adapters)
HTTP status codes
Dealing with errors
Designing an Ember friendly API in laravel
League/Fractal transformers
Middleware for serialization (we want to still just be able to return results from the server in the traditional Ember sense - use Middleware to handle serialization)
Data driven todo application
Refactor the todo application in chapter 5 to deal with persistence
Query params
So far, endpoints have been simple. Make them queryable while maintaining bookmarkable pages.
Add a search function to our todo application
Ember Addons
Introduction to Ember Addons - adding moment.js to our todo application
Transition animation
Introduction to LiquidFire
Authentication
Adding JWT to your application using tymondesigns/jwt and ember-simple-auth-token
Recap
A look at how little code has been used to achieve a fully dynamic todo application
Ember testing
Look at the ember testing story, differences between integration and unit testing.
Refactoring
Refactor our application to use the pods structure and components



Ember CLI





Anatomy of an Ember App





ES6/ES2015




