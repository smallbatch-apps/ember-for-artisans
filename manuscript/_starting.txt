
-# A simple application in Ember

# Getting Started With Ember CLI

One of the best features of Ember is Ember CLI. It's a friend, a companion, maybe even a lover. 

## Installing Ember and Creating a new Project

Step one of starting with Ember is to install Ember CLI globally to your system. This assumes NPM is available, of course. On any reasonble and current dev machine it should be.

~~~~~~~~
npm install -g ember-cli
~~~~~~~~

Ember CLI is a pretty solid comparision to Laravel's artisan command line tool in that it has generators and so on, but it packs a lot more punch. Basically if there is stuff you don't want to do - dependency management, setting up task runners, installing addons, etc, Ember CLI will take it off your hands. First among these is scaffolding an entire new application.

~~~~~~~~
ember new todo-list
~~~~~~~~

This command will create a whole new Ember application, ready to run once NPM gets finished with its admittedly slow business. If you think it can't be that simple, you're right, of course. You have to change directory into your new , and run `ember server`.

Now you have a properly served app at `http://localhost:4200`, configured with live reload, a comprehensive asset management system, build chain, ES6 transpiling, and a smug sense of superiority toward people who act like Ember is too hard. You may also notice that the build time takes around 8 - 10 seconds. This only occurs the first time. Subsequent builds are near instant.

This might go without saying, but that terminal window needs to be running to keep serving stuff, so make another one at the same location to input further commands.

T> You should really install the Chrome addon called Ember Inspector. It does a remarkably good job of debugging Ember apps, showing what all the bits are doing, displaying model data, deprecation warnings, etc. All further discussion in this book assumes you have it installed, because you're clearly a smart person who makes good decisions.

If you go to the URL that `ember server` gave you, you'll see Ember's default install app, featuring an adorable hamster. The first step to customising this requires a file that *used to* exist, but now inexplicably doesn't. This is a sort of base template file. The root, base, home, etc, of an Ember app is called `application`. We would like to have a base application template to put our nav and stuff in. We can make one easily.

~~~~~~~~
ember generate template application
~~~~~~~~

Now would be a pretty good time to make sure whatever editor you use is set up with the new project, or to open the directory, or whatever. Note that while editors often have functionality to make and manage files we shouldn't be needing those. That said, if you have an editor or IDE that has a command line feel free to use that. PHPStorm, Webstorm and Visual Studio Code all definitely do.

That file will be generated instantly, building nearly as quickly. It will also stop the application working, and make it a white screen. Ignore that. We've replaced the base template with an empty file, and we'll fix that now. If you go to `apps/templates` in your editor, you'll see it there now - `application.hbs`. A .hbs file is a handlebars template file. Not too dissimilar to Laravel's Blade. Much like blade, an empty root template with no sections or yields results in a screen that redefines "minimalism". What it needs is an `{{outlet}}` , so just type that in and save it. This is functionally similar to Blade's `@yield`. Add a H1 tag, and whatever markup you like, save, and we'll get on with it. You'll probably notice that Ember rebuilds everything automatically on your file change, and updates the browser accordingly. Wizards. If you can still see your `ember server` tab you will be able to see what it's building, too. That build process even gives you a heads-up about Javascript standards errors, which can often be very useful.

# Routes in Ember

The core thing to know about Ember is that it's all about the routes. Everything is build around the route you use, the actual request string. A Route in Ember is a specific object dedicated to handling a given URL pattern.  This simplifies Ember greatly - the current URL is the current state of the app, and can be rebuilt or reloaded or shared without issue. Back and next buttons, sharing and bookmarks all work perfectly fine.

That route-centric nature leads to a core difference between Laravel and Ember. The "route" is central to Ember in a way that has no comparison with Laravel.

There are some core jobs that this sort of MVC framework has to do. 

1. Accept the string of the path
2. find the code that's intended to execute when the path is hit
3. Get the model data that will be needed
4. Get the template used
5. Set up the template to use the data
6. Serve on toast

Ember and Laravel divide these jobs differently. In a Laravel app the Router could pretty much handles all of the above. More typically, 1 & 2 are handled in the router. That will also define a controller. In the controller you get the data and template explicitly - items 3 and 4. Variables are injected directly into the template in the controller as well. Returning from the controller triggers the render.

In the case of Ember, the Router handles 1, the Route (note the distinction) handles 2 & 3, while 4 is handled by Ember's conventions which dictate the template's location. From then on things are quite different. Ember's lifecycle is critically different from Laravel's set-and-forget. Everything has to stay live. Ember therefore needs to set up a "context", an environment where a template's values can be routinely set and modified. In principle this means binding a controller to handle the live-ness with a template. In practice the controller is often not needed. However, one of the core things a controller does is to handle actions that are occurring on the page. The more stuff a particular view does the more likely a controller is to be needed and useful.

The role of a Route, therefore, is critical in Ember. It sets up everything that comes after. It's always going to be our first step when adding new features or functionality. For now we'll put in only routes, but as we start adding functionality controllers will come into play.

W> If you do a lot of reading you'll quickly learn that Controllers in Ember are deprecated, dead, unnecessary, broken, being replaced or any other negative term. It's true that much of the common use of Controllers is better put elsewhere now, but there is absolutely no intention of making controllers go away. Components take up a lot of their code, but they still have significant value, **especially** in a component heavy app.

## Building our first route

We're going to start off with a really basic route. We want an about-us page, because it's apparently mandatory and it gives us a nice static page. The process of this is trivially simple. Ember CLI as well as scaffolding an application can also generate pieces of that application. This is not only something you can do but something you definitely should. Generating them like this is easier and faster in every way, and helps ensure things stay within Ember's happy conventions.

~~~~~~~~
ember generate route about-us
~~~~~~~~

You'll see that run through a few lines of output, generating the files we need. If you open `app/router.js` you'll also see if you have a look that the router has been updated to add this new route. The main things added are a pair - the template and the route. We don't actually need to edit this manually, and we never will. We're just looking out of interest.

T> You don't actually have to type `generate`, just typing `ember g` will do the same thing with less tapping. We were trying to be explicit, but from now on `ember g` will be used.

If you edit the new `apps/templates/about-us.hbs` you'll see that it's just a blank file. Throw a `<h2>About Us</h2>` at the top. Feel free to put in some lorem ipsum text so you can feel like a real designer, and we'll get on with it. You should also make sure you delete the `{{outlet}}`. We're not going to be putting any sub-routes in here or anything. It won't break anything if you leave it there.

Going to that route at `http://localhost:4200/about-us` will show us exactly what we would expect to see.

A look at `apps/routes/about-us.js` shows us some pretty standard Ember ES6 boilerplate. More complex routes can have things like the model, actions, various lifecycle hooks and properties set in here, but our route is static HTML, so we don't really need any of that. In fact... delete it. Not the content. The whole `about-us.js` file. Seriously, do it. If you take another look at the page, you'll see that nothing's changed. Apparently routes aren't so important after all!

What's happening here is one of the great strengths of Ember. It has a strong philosophy of "Convention over Configuration". A lot of people take that to mean that Ember follows a strict set of rules. But a better view is to think of it as mutual trust. If Ember's conventions are followed, it behaves with logical and reasonable defaults. In this case, a route is needed, and in fact it's so much needed that if not found, Ember will build one itself, identical to the default one from the generator. This is a **very good thing**, and it means you can simply remove files that don't do anything.

# Starting with Models

## A more useful Route

Very few routes are going to be that static. If you're using the SPA pattern to build entirely static content you need to have a good long think about what you're doing with your life. We're going to now use the same process to build a second route.

~~~~~~~~
ember g route todo
~~~~~~~~

## Adding a model

This route is going to list all the todo items, so it's going to be much less static, and will need actual data, which is a core responsibiility of the Route. This just means adding a model hook to the existing boilerplate for your todo route.

~~~~~~~~~
// app/todo/route.js
export default Ember.Route.extend({
	model(){
		return [
			{id: 1, checked: false, text: 'Buy milk'},
			{id: 2, checked: false, text: 'Buy bread'},
			{id: 3, checked: false, text: 'Bring back Firefly'},
			{id: 4, checked: false, text: 'Conquer planet'}
		];
	}
});
~~~~~~~~~

W> Note that the code used in Ember objects always starts with a line of `import Ember from 'ember';`. We're not showing that in these examples, but it will be part of the code generated. It is not shown in these examples **purely to save space** and is definitely required for the code to function.

This data is now part of the route, and accessible in its templates, etc. This is obviously a simplified example. You would rarely hardcode data like this. A more common approach would be to use Ember Data models, which is kind of like the equivalent of an Eloquent model, forming an ORM for API access. Most particularly this abstracts away persistence, which we're not going to do here so we'll look at it more later.

If you're paying attention, you'll notice that the Route object contains the model data, but nothing at all seems to explicitly state the **template**. The location and name of the template are defined by conventions of name and structure of routes. In this case, the `app/routes/todo.js` route **must** be calling an `app/templates/todo.hbs` template. That's the convention. And of course, there we'll find it, so open it up.

# Working with Templates

## Looping over the model

Looping over model data is nice and easy. Ember (like Blade or any other template system) has systems for looping over data. 

~~~~~~~~
<h2>My Items</h2>

<ul>
{{#each model as |item|}}
	<li>{{item.text}}</li>
{{/each}}
</ul>

{{outlet}}
~~~~~~~~

If the `|item|` is throwing you, now would be a great time to point out that just `item` used to work, but this newer syntax has some  benefit that is a bit irrelevant here, specifically to do with maintaining object scope when passing data into components. In short, it's how you have to do it.

Speaking of which, you should keep the `{{outlet}}` there too, at the bottom. We **will** be pulling content into this for subroutes.

If you go back to the browser and put in `http://localhost:4200/todo/` you'll again see that it does exactly what it should.

## Adding some links

It's at about this point that the staggering ugliness of what we're working on is starting to bug us. We can fix that now, starting as ever with usability issues. No one is ever going to type in your correct route urls, so let's make some actual proper links. Obviously you could just write `<a href="todo">`, but you'd lose all your SPAness, and that wouldn't be good. Ember has a nice helper for that, the `link-to` helper. 

We can provide a number of arguments to this thing, but the basic usage is a single argument to link to a route. If we edit the `apps/templates/application.hbs` file again we can put the following in and have a nice clean set of links for our application.

~~~~~~~~
<ul>
    <li>{{#link-to 'index'}}Home{{/link-to}}</li>
    <li>{{#link-to 'about-us'}}About Us{{/link-to}}</li>
    <li>{{#link-to 'todo'}}ToDo List{{/link-to}}</li>
</ul>


{{outlet}}
~~~~~~~~

## Understanding Outlets

Clicking between these is now handled as a transition inside the app. You'll note that the URL changes, but the interface doesn't really move around, as only the content of the `{{outlet}}` is changing. It's hard to really tell on such a simple site.

The outlet in Ember is very much like Laravel's `@yield` functionality, pulling in a sub-template. Unlike Laravel, which only needs to build the structure up once, Ember outlets are highly dynamic. They invariably have their contents changed on the fly. Any template that is rendering a sub-template needs to have an outlet there to take that. To put it another way, every route needs an outlet to go into. Our `about-us` route (and anything else on that level) goes into the application template's outlet. 

For now all of our routes are a flat structure. The only place they can or should render into is that one outlet. That will change.

# Making it look less awful

If you have functioning eyes you'll probably be moderately unhappy with the current aesthetic. We don't want to put too much effort into layout because it's out of scope of this book, but we want to get a nice clean look.

## Installing Bootstrap and Font Awesome

The simplest way to do this is to implement Bootstrap. Bootstrap is available as an Ember Add-on, which is a good way to learn how to use these. The process is simple thanks to EmberCLI: `ember install ember-bootstrap`.

This will handle all the NPM stuff and Bower stuff, and add in any CSS or JavaScript files that are required by the addon. Just because I know we're going to use it anyway, let's throw some Font Awesome icons in there as well. Enter `ember install ember-font-awesome` and that one will do the same stuff.

T> Installing a new addon is one of the few things Ember server can't quite get its pretty little head around. It doesn't have access to the new files that are added while it's running. Just kill it (control + c, and yes, even on a Mac) and type `ember server` again and it will come back up in under a second.

To show how easy these addons are to use, we'll just do some more setup to make things look better. Open up `apps/templates/application.hbs` and wrap all of the contents of that in a bootstrap container div. 

~~~~~~~~
<div class="container">
// everything that was already here
</div>
~~~~~~~~

That's really all there is to it. The page will now have your title in a better font and with Bootstrap and Font Awesome ready to go, no gulpfile or build process, and you don't even have to include the CSS or javscript, that's already done for you. How far you take the Bootstrap layout is entirely up to you, but we're going to go with very minimal layout here because otherwise the markup gets bulky.

One thing we will do is "fix" the nav with large slabs of Bootstrap boilerplate first to replace all our simple, semantic code.

~~~~~~~~
<nav class="navbar navbar-default">
<ul class="nav navbar-nav">
    <li>{{#link-to 'index'}}Home{{/link-to}}</li>
    <li>{{#link-to 'about-us'}}About Us{{/link-to}}</li>
    <li>{{#link-to 'todo'}}ToDo List{{/link-to}}</li>
</ul>
</nav>
~~~~~~~~

Now it looks and functions like a real Bootstrap nav. With one exception. If you click around, you'll notice that the link changes slightly, but not like a full active link in Bootstrap should be. There's a reason for this - Ember is adding a class to the currently active link, `class="active"`. But Bootstrap expects that code on the `li`, not the `a` tag. There are a bunch of solutions to this, most of which are kind of hacky. The cleanest and easiest is another addon. `ember install ember-cli-active-link-wrapper`.

Installing this lets you replace the `li`, **not the link-to** with an active-aware version.

~~~~~~~~
{{#active-link}}{{#link-to 'index'}}Home{{/link-to}}{{/active-link}}
// and the other two
~~~~~~~~

Click around and the problem is fixed. Nice and simple.

# Nested Routes

## How to show a single item

As well as showing a list, we want to be able to view, and more particularly edit, a single item. The best way to do this is to use nested routes. This means that our Todo route will have a number of options - notably `show`, `edit`, and `new`. Before we get started on that, we need to make sure the parent template, our todo template, is ready. If we open that up (`apps/templates/todo.hbs`) You can see our listing of each todo item. What we need to do is make sure there's an `{{outlet}}` somewhere on this template, or any sub-routes we generate will have nothing to render into. If you don't see one there it's because you replaced it before when adding the foreach loop. If you just pasted the foreach loop above the outlet you should be good to go, but either way, just make sure it's there. Not having an outlet is a common cause of confusion when nesting things.

## Generating a nested route and the Ember Router

Generating a nested route is not really harder than generating any other. `ember generate route todo/show --path=:id` will get the job done handily. This also sets the path option in the route, which is worth a look at now.

If you open the router file again at `app/router.js` you'll see the new route. All the generator work we've been doing has been also added into here automatically, so we haven't really needed to touch it, but it's good to have a look. The todo route is obviously different to the others, now being a nested route. Inside that the show route has a slightly different syntax as well, with a property object on it containing the path. The `:id` in there is much the same as Laravel's `{id}`, but the first part of it is implied from the parent route, so the whole route is `todo/123` rather than just `123`. That object, and specifically the path part of it, is implied in all routes. You could write our about route as `this.route('about-us', {path: 'about-us'});` if you wanted, but in the case of route paths that exactly match the route name it's implied. It's common for Ember to have these sensible defaults to make things more easy to read.

Rather than typing this URL in to check it, we're going to link to it properly. Edit your `app/templates/todo.hbs` file and go to the loop and add some links with the link-to helpers. The third second argument to the link-to helper, which we haven't used yet, is to pass in the object you're transitioning to. We can look look like this. I'll add some Bootstrap markup at the same time.

## More advanced link-to

Rather than typing this URL in to check it, we're going to link to it properly. Edit your `app/templates/todo.hbs` file and go to the loop and add some links with the link-to helpers. The second argument to the link-to helper, which we haven't used yet, is to pass in the object you're transitioning to. We can look look like this. I'll add some Bootstrap markup at the same time.

~~~~~~~~
<ul class="list-group">
{{#each model as |item|}}
	<li class="list-group-item">
        {{#link-to 'todo.show' item}}{{item.text}}{{/link-to}}
    </li>
{{/each}}
</ul>
~~~~~~~~

We have a template now as part of this generation, and it should be at `app/todo/show.hbs`. All we really need is some basic layout in this and we'll be good to go. Note that the model for a single todo will be a todo item, rather than the collection we used in the parent route.

## The template for a single item

We have a template now as part of this generation, and it should be at `app/todo/show.hbs`. All we really need is some basic layout in this and we'll be good to go. Note that the model for a single todo will be a todo item, rather than the collection we used in the parent route.

~~~~~~~~
<!-- app/todo/show.hbs -->
<div class="container">
	<div class="row">
		<div class="col-md-2">Text:</div>
		<div class="col-md-10">{{model.text}}</div>
	</div>
	<div class="row">
		<div class="col-md-2">Status:</div>
		<div class="col-md-10">{{model.checked}}</div>
	</div>
</div>
~~~~~~~~

Now you can go to the application, and click through to the Todo page, then click on any of the individual items to view its details.

# Debugging with the Ember Inspector
 
This seems to be working now, but there's a bug in it. If you refresh the page, you'll see our todo item's text field gets wiped. Each URL should work on its own merits, so this isn't the behaviour we want. I suggested earlier that you install the Ember Inspector extension for whatever browser you use, and am now going to assume you did so. We can use Ember Inspector to give us a bit more of an idea of what's happening with this code.
 
Open your browser debug toolbar with F12 and you'll see a tab for Ember. For the most part that doesn't do anything, but when browsing an Ember app it starts to pop in a bunch of details for us.
 
Of particular interest to us is the Routes section on the left hand side. If you click on that it will show us the structure of our Ember application. In particular, it shows each Route, and what is populating that route. It will show you the application route, and in a higher level the about and todo route, inside which is the todo/show route. It also shows the resources that are used to make this. It will show you which route objects are present, the name, and what url pattern triggers that route. It will also show you what template and what controller are on the route. You'll notice that a lot of things are greyed out. All of these elements "exist", but some more than others. Every file or object listed here is something that's part of Ember's structure. But if not found, Ember will happily mock one up. For example, there is, and always has been, an application route for your Ember app. It's not at all uncommon to generate a real, concrete route file and put things inside that. We simply don't need that, but you'll notice there **is** an application template. 
 
This is all very interesting, but to get a better idea of our issue here, we need to go to the data tab here. Depending on when you do this, it will be either full or empty.
 
The Data tab is showing what model data backs the current route. If you go to the Home route you'll see it has nothing. Go to the todo list and it fills up. Go to the route for an individual todo item and it will still have data. Refresh on an individual item and everything goes away. This pretty much sums up the problem. This route, has no model.
 
We were masking that issue when we navigated through the interface, beause we passed an item from the todo collection to serve as the model. However, when stripped of the access to the todo route, the lack of model on todo/show becomes a problem. Thankfully it's a problem that's easy to fix.

We **could** just dump in the same JavaScript array as the parent route, search it and return the correct object. But what we really want to do is get that array directly from the parent. Thankfully, Ember provides a nice simple way to do that.

Note that in this case we need to pass the parameters into the model hook. That wasn't necessary in the listing, because it didn't take any parameters.

~~~~~~~~~
// app/todo/show.js
export default Ember.Route.extend({
	model(params){
		let items = this.modelFor('todo');
		return items.find(function(item){
			return +params.id === item.id;
		});
	}
});

// alternatively shorter form ES6
return this.modelFor('todo')
    .find(item => +params.id === item.id);
~~~~~~~~~ 

If the `+params.id` part is confusing, it's an unusual but standard syntax. This isn't Ember, it's just a JavaScript unary operator.

T> If you look at the docs for link-to you'll see that it shows the third option as the id, which would make you think you pass in todo.id instead of the whole todo object. Either will work, but they work slightly differently. Passing in the id makes the show route run its own model hook, whereas passing in the object overrides it. In this app it's not noticeably different, but in many larger applications that show route model hook will run an API request. This would make passing in the model significantly faster and cleaner.


# Editing

We're going to start off by editing our existing items. There's a reason for that - it doesn't involve us managing the addition or removal of records, which we'll deal with separately.

## Another nested route - edit

What we need is another route, for a new todo item. `ember generate route todo/edit --path=:id/edit`.

If we have another look at our router after doing that we'll notice that the new route is **not** nested inside the show route, even though it might look like it from the URL. The path and the nesting absolutely do not have to be identical. How you structure the nesting should be based not on relationships between the **data**, but on relationships within the **interface**. The show and edit route are siblings, and from an interface point of view we want the edit form to replace display, not sit inside it.

This is a key for Ember that took me a while to really **get**. You should be thinking of all of this as the structure required for your interface - not the structure you require for your data. If the interface is nested, nest the routes. If they're not... don't. The relationship between data types, etc, is irrelevant. It's the relationship between the interface elements that really matters.

The `edit` route needs another model hook, which is the exact same code as the `show` model hook, so just grab that and paste it into the routes file, which in this case is located at `app/routes/todo/edit.js`. 

## The Input Helper

Much like links, inputs are an important part of an Ember app, as they are where user changes happen. As such, they have a special helper. As well as the obvious properties, such as `class`, the input helper critically takes a value property. That value is the model property being edited or created. The `app/templates/todo/edit.hbs` file should look very much like the following.

~~~~~~~~
<!-- app/todo/edit.hbs -->
<h3 class="no-top-margin">Update Todo Item</h3>

<div class="form-group">
    <label for="text">Text</label>
    {{input value=model.text class="form-control"}}
</div>
<div class="form-group">
    <button class="btn btn-info"{{action "update" model}}>{{fa-icon "cloud-upload"}} Update</button>
</div>
~~~~~~~~

Again, we'll update the todo loop to provide a link to this new edit route, as well as add some Bootstrap and Font Awesome magic to the interface. The `{{action "update" model}}` part of this is an action helper, telling Ember to run the update function on click (the default), and passing in the model at that time.

~~~~~~~~
<ul class="list-group">
{{#each model as |item|}}
    <li class="list-group-item">
    {{#link-to 'todo.show' item}}{{item.text}}{{/link-to}}
    {{#link-to 'todo.edit' item}}
        {{fa-icon "pencil" class="pull-right edit-link"}}
    {{/link-to}}
    </li>
{{/each}}
</ul>
~~~~~~~~

T> Note the simplicity of the implementation of Font Awesome, thanks to the add-on we installed earlier.

If you edit the details, you'll notice that as you change the details in the field, you also directly change the actual list-item. This is something called "Two-way binding". Two-way binding is a mixed blessing that looks great in a demo, but can cause state conflicts in a larger application. We'll deal with that in our larger application. You'll also notice that when you hit the "Update" button things go very badly wrong. The error says that there is nothing to handle the "update" action, and this is entirely accurate.

## Actions

Actions in Ember can be handled on a route (as mentioned before) but in this case we'll handle it on the controller, the todo/edit controller, specifically. Step one is obviously making that controller.

~~~~~~~~
ember g controller todo/edit
~~~~~~~~

If you open that file at `app/controllers/todo/edit.js` you'll see a new controller file, roughly the same as our default route, or really anything newly generated in Ember. We need to add an actions object to that controller, containing an update function.

~~~~~~~~
//app/controllers/todo/edit.js
export default Ember.Controller.extend({
    actions: {
        update(item){
            alert('saved');
        }
    }
});
~~~~~~~~

You'll hopefully have noticed that parameter, the item parameter. That's being passed through in the action helper above, and contains the model initially provided by the route. All of the actual changes to the object have been done in the model by editing it in the form, so in this case there's nothing to actually save. The model has already changed. In a real application this would be where those changes were persisted, saving the data back to the API, etc. 

# Testing in Ember

We want to change direction now. We've just been ripping through this and adding functionality. This is great, but it misses some of the key benefits in Ember. We want to be able to make complex functionality that's tested and maintainable.

## How to run your tests

The simplest way to run your tests is to go to `http://localhost:4200/tests`. This will show a page with all of your tests on it. There are two possibilities at this point. If you've been largely ignoring me, and doing things at your own pace or however you want, everything will be fine, all tests green. If you actually listened and followed the instructions to the letter you have at least one major error you need to fix. There's a life lesson in there.

The error is pretty simple. When we generated the routes earlier, EmberCLI also generated test stubs along with them. The tests are pretty trivial, they just tests that the JavaScript is valid and present. However, if you recall from earlier, we actually deleted the `about-us` route. It's no longer present. We can get rid of that error by simply deleting the `tests/unit/routes/about-us.js` file. There's no point testing code that doesn't exist. With that file gone, it should just test green.

This is the easiest way to test, but it's not the best. The best is to use EmberCLI. We can run the tests by simply running the command `ember test`. There's a fair chance that will get an error, too. It will say something along the lines of "Unable to find PhantomJS". Phantom is a "headless browser". It lets JavaScript execute in a command line, with no interface or display, and shows the results of the page tests, all run in memory. It's not exactly a default install. On a Mac at least it's easy to set up. `brew install phantomjs`

With that in place, `ember test` should happily display successful output.

## How to write tests

For the most part, Ember will generate the tests for you, or at least a test stub. This is a good starting point and saves you from having to do too much work. You also get the benefit that the intial tests in the stub are jslint tests, so if you violate any important JavaScript style rules it will get picked up.

Our application is relatively simple, and most of it is default framework behaviour, which we don't need to test ourselves. There is little complex calculation that could be helped with a unit test. What we actually want to test is our functionality. That when you save, things get added, that kind of thing. We can do that with acceptance tests.

Acceptance tests are essentially tests that confirm the code meets requirements. They don't test **how** it works, just run through the interface and confirm the expected behaviour. Note that this is **behaviour**. We shouldn't be excessively testing display except where user activity is changing it.
 
# Acceptance Testing
 
Acceptance testing is a sort of automated test specifically about whether the application meets the specifications or requirements. It is fairly typical for an acceptance test to check and confirm the acceptance criteria of the business or client.
 
Unlike unit tests, which intend to test tiny pieces of the site in great detail while isolated, acceptance tests are for broad, actual user-style functionality. An acceptance test might check, for example, that a user can log in, or that a signup form works.
 
## Creating an acceptance test
 
The format should come as no surprise. `ember g acceptance-test about` will generate a file at `tests/acceptance/about-test.js`. Note that this is not in `app/`. The tests are not part of your app.
 
There is one placeholder test in place that just say `test('visiting /about', function...`. The test is then very readable, close to normal language. The vast majority of acceptance tests follow a consistent pattern: visit a page - do a thing - check the result. You can see our test here doing approximately that, though it doesn't have much to do. It visits a page, and then just confirms that you're actually on the page it thinks it's on. A trivial test, but it shows the pattern. If you run `ember test` you'll see that as an addition to our previous suite of tests.
 
Since we're creating some new functionality, let's do this in a Behaviour Driven Development (BDD) approach. This means we write the tests **first**, even before we have working code. We want to create a new Todo item in the interface. BDD gives us an opportunity to think through what it will take to decide when that "works".
 
~~~~~~~~
ember g acceptance-test new-item
~~~~~~~~
 
Opening up `tests/acceptance/new-item-test.js` will show you the same boilerplate as for about. This is a lot less useful, though. There isn't a valid route at `/new-item`.
 
What we're going to want to do is pretty simple: Go to the todo list page. Click "Add Item" button, fill in the form, click "Create" button. Confirm the form closed and that the item has been added to the list.
 
So let's get started. Ignoring most of the wrapper, the bit we care about is the part starting from `visit()`.
 
~~~~~~~~
visit('/todo');
click('#new-item-button');
fillIn('input.new-item-text', 'Some random text');
click('#create-item-button');
~~~~~~~~
 
That pretty much covers it. We want to go to the todo items page, click on the element with the given id, fill in an input with that specific class with given info, and then click the other submit button.
 
There is a principle in testing, often phrased as **Arrange, Act, Assert**. You set up your data or state, then do the "thing", then check it. In this case there's little to arrange, but many acceptance tests would create a test customer, or mock data. This is all the act, all the things we need to do to confirm. Now we need the assert, which is all of the lines wrapped in `andThen`.
 
If you're wondering why the `andThen` instead of just following a logical chain, the `andThen`  provides security around potentially asynchronous calls and actions. It will only run these when everything is clear and ready.
 
~~~~~~~~
andThen(function() {
    assert.equal(/*we haven't really thought this through*/);
});
~~~~~~~~
 
So how do we confirm this stuff? There are a few things we need to verify. The main one is that the new item actually got created. The simplest way to check that is to see how long the list was before and after. It will also be the last item, and we also want to check that its text matches the provided string. We also want to make sure that saving redirects us to the show page. So let's do some refactoring and put it all together.
 
~~~~~~~~
test('Creating a new todo item', function(assert) {
   
    const itemText = 'Some random text';
    let itemLength = find('.list-group-item').length;
 
    visit('/todo');
    click('#new-item-button');
    fillIn('input.new-item-text', itemText);
    click('#create-item-button');
   
    andThen(function() {
        let newListLength = find('.li').length;
        let lastItemText = find('.li:last-child').text();
 
        assert.equal(itemLength + 1,  newListLength);
        assert.equal(lastItemText, itemText);
        assert.equal(currentURL(), '/todo/'+ newListLength);
    });
});
~~~~~~~~
 
There's a lot to unpack here, but most of it isn't as mysterious as it looks. In fact, probably the most complex thing here is `find()`. All that does is wrap around jquery's excellent `$()` selector voodoo. As a result things like `.length` and `.text()` are simply well known jquery (or js) functionality. This also means that `find()` is vastly more flexible than it has any right to be, allowing crazy jquery selectors like `div.user-list:visible` or `input[value="Buy Pizza"]`.
 
T> If you're thinking that littering your tests with selectors is a bad practise you're dead on. A better approach to this is to use page objects, specifically by installing `ember-cli-page-objects`. This lets you define the interface of a page up front, and interact with it much more cleanly, such as `searchPage.visit().keyword('cactus').submit()` and asserting on `homePage.title`. You can also wrap logical groups of actions, like "createNewPost" to fill in multiple field. It is highly recommended to do this if doing a large amount of acceptance testing.

When you run this test you'll notice something else. It fails. This is the plan. This is the point of this kind of testing. Write a failing test first, then make it not fail. When it doesn't fail, the feature is working. This is Behaviour Driven Development.

# Creating a new item

The new item is slightly more complex because it affects the collection as well as an entire item. It's not much more so, and certainly starts off the same.

## As always - generate another route

~~~~~~~~
ember generate route todo/new
~~~~~~~~

We can grab the exact same form details, copying the entire of `edit.hbs` and pasting it into `new.hbs`, then just changing the word "Update" where it appears to "Create". Don't forget to change the action! That will be `create`, this time course.

Before we forget, we need to add a button to create a new item, and we need to put it into `app/templates/todo.hbs`. Under the list you can just put the following line to get a nicely styled button.

~~~~~~~~
{{#link-to 'todo.new' class="btn btn-info"}}
    {{fa-icon "plus-circle"}} Add item
{{/link-to}}
~~~~~~~~

The content of the new route is slightly less obvious than some of the others. It might not be initially obvious that we actually need a model. After all, this route is about **making** a model. But creating an empty model up front gives us something to edit. In fact we need a model backing the new template in order to give the template something to hook into, so that when the form is being edited it's making changes to *something*.

In theory what we need to return from the model hook is a blank Ember Object. In practise, Ember will wrap anything returned from the model hook in its own voodoo, so we literally just need to return an empty javascript object.

We also need an action, and this needs to do just a little more than the edit route. In particular it needs to add the new item to our listing. Conveniently, the listing is actually the model for our parent route, so we can add it on there.

The `routes/todo/new.js` file will contain:

~~~~~~~~
export default Ember.Route.extend({
  model(){
    return {};
  }
});
~~~~~~~~

We will also need an action. We'll put this on a controller, so we'll need another one. That one will be `ember g controller todo/new`. 

~~~~~~~~
export default Ember.Controller.extend({
  actions: {
    create(item){

      let collection = this.modelFor('todo');

      collection.pushObject({
          id: collection.length,
          text: item.text,
          checked: false
      });
    }
  }
});
~~~~~~~~

A lot of that should be easy to follow. The actions object contains a single create function, which is passed the previously mentioned now-not-so-empty model. Inside that is where newer things are happening.

The collection of all the different todo items is the model for the todo route, so we grab that. It's simply the easiest thing to do, and to be honest it most clearly reflects the intent here. This is an Ember Collection object, so we use the `pushObject` method to add a new item to it. We could just use the standard array push, but pushObject respects all the watchers and magic of Ember, making it immediately just as usable as any other item in our collection. Again, it would be typical to persist this new item back to the server as well, but a step not being taken by our demo application.

If we run our `ember test` command again we will notice that the test now successfully passes. Congratulations, you are now an expert at  **BDD** and can put it on your resume. 

# Checking an item

There's only one real requirement left. A todo list that can't check off items is in poor shape. We need to add that functionality. The first step is to figure out whose responsibility this is. It might be initially tempting to assume this is the responsibility of the edit route, but remember, from an interface point of view we really just want to handle this directly in the todos listing view, not go somewhere else to do it. 

## Creating the tests

Again, we're going to BDD this, so let's start with `ember g acceptance-test todo-check`.

And again, this is going to need some thinking through. What we want to do is click the **second** checkbox, and then confirm that the item is crossed out. This should be enough to confirm that our behaviour is as expected.

~~~~~~~~
test('Creating a new todo item', function(assert) {
   
   var row = find('li:nth-child(2)');
   
    visit('/todo');
    click('.check-icon', row);
    
    andThen(function() {
        let rowIsChecked = row.hasClass('checked');
        assert.ok(isRowChecked);
    });
});
~~~~~~~~

If you run your `ember test` command again you'll find this doesn't pass, and for obvious reasons. We haven't done anything to this code that would make it work.

## Adding the functionality

So what we need to do is put an action in the todo list itself, and that means we need to add a controller for that as well. `ember g controller todo`.

T> We should admit at this point that the actions we've created here could have been entirely written on the existing Route objects, rather than creating a controller. However, there are limits on what can access an action on a Route. In particular, components can only talk to actions that are on the controller - that is the "context" they run in. As we're wanting to refactor this later to use components and just clean up generally, we're going to stick with controllers.

## A simple action

This action is surprisingly small. All we really want to do is toggle on and off a particular property on a given item that's passed into the action. To do this we just need to add the action object with this function to the todo controller.

~~~~~~~
//app/controllers/todo.js
export default Ember.Controller.extend({  
    actions: {
        checkItem(item){
            Ember.set(item, 'checked', !Ember.get(item, 'checked'));
        }
    }
});
~~~~~~~

This takes in the item, and then uses `Ember.set` to update a property - checked, in this case. Using Ember.set instead of something like `item.checked = true` allows the change to propagate all through the app, keeping everything properly in sync. If you try and just set the property directly Ember Inspector will spit up warnings at you. The `Ember.get` plays a similar role, returning a safe version of the value of the property on that object, and the ! just causes it to invert. Again, this would be the point where we would be saving back to an API.

T> This could actually be written quite a bit more simply as `item.toggleProperty('checked');`, which is a shortcut for a lot of the above.

## Connecting up the action in the template

The only other thing to do is add a checkbox with the action and a bit of styling on the list item. We'll start by modifying the todo list template again. This is now our complete todo.hbs, including some Bootstrap layout and all the additional buttons and classes.

~~~~~~~
<!-- app/tempates/todo.hbs -->
<h2>Current Items</h2>

<div class="row">
<div class="col-md-4">
<ul class="list-group">
{{#each model as |item|}}
    <li class="list-group-item 
        {{if item.checked "checked" "unchecked"}}">
        <span class="check-icon" {{action 'checkItem' item}}>
            {{fa-icon (if item.checked "check-square-o" "square-o")}}
        </span>

        {{#link-to 'todo.show' item}}{{item.text}}{{/link-to}}
        {{#link-to 'todo.edit' item}}
            {{fa-icon "pencil" class="pull-right edit-link"}}
        {{/link-to}}
    </li>
{{/each}}
</ul>
    {{#link-to 'todo.new' class="btn btn-info"}}
        {{fa-icon "plus-circle"}} Add item
    {{/link-to}}
</div>
<div class="col-md-4">
    {{outlet}}
</div>
</div>
~~~~~~~

The new code is mostly in the span that we've thrown an action on and put an icon inside. A conditional `if` as the second parameter tells it whether to have the icon checked or unchecked. Similar code exists above and tells the class whether to be checked or unchecked so our styling will work.

If we run `ember test` we get the confirmation that we've met our requirement.

## Handling CSS 

Styling isn't something we've looked into yet, so now is the time. Open up `app/styles/app.css` and you'll have an empty stylesheet to work with. Adding any styling into there will be immediately built and put into the app.css used by the application. We're going to dump in some css mostly just for look. What exactly it does should be readily apparent.

~~~~~~~~
.check-icon {
  display: inline-block;
  width: 15px;
}

li.checked {
  text-decoration: line-through;
}

li .edit-link {
  display: none;
}

li:hover .edit-link {
  display: inline-block;
}
~~~~~~~~

Most of it is just polish so that we don't see the edit icons unless we mouseover the list item, and the second rule is to make checked items have a strikethrough effect.

This doesn't just have to be CSS. If you're wanting to use Sass, and you should, it's trivial to set up. Just install `ember install ember-cli-sass` and you can just rename `app/styles/app.css` to `app/styles/app.scss`, or create a new one. 

That's it. We're done. We've built an Ember app. With the knowledge of how to do it and given a reasonable expectation of the details of the layout, this whole thing could be done in about 20 minutes. Sure, it doesn't do a whole lot. But it does let you see clearly that Ember does **not** have to be hard. It's got a quite clear structure, and is highly capable without having to worry about how to set things up.