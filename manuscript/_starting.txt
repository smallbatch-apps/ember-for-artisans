
-# A simple application in Ember

# Getting Started With Ember CLI

One of the best features of Ember is Ember CLI. It's a friend, a companion, maybe even a lover. 

## Installing Ember and Creating a new Project

Step one of starting with Ember is to install Ember CLI globally to your system. This assumes NPM is available, of course. On any reasonble and current dev machine it should be.

~~~~~~~~
npm install -g ember-cli
~~~~~~~~

Ember CLI is a pretty solid comparision to Laravel's artisan command line tool in that it has generators and so on, but it packs a lot more punch. Basically if there is stuff you don't want to do - dependency management, setting up task runners, installing addons, etc, Ember CLI will take it off your hands. First among these is scaffolding an entire new application.

~~~~~~~~
ember new todo-list
~~~~~~~~

This command will create a whole new Ember application, ready to run once NPM gets finished with its admittedly slow business. If you think it can't be that simple, you're right, of course. You have to change directory into your new , and run `ember server`.

Now you have a properly served app at `http://localhost:4200`, configured with live reload, a comprehensive asset management system, build chain, ES6 transpiling, and a smug sense of superiority toward people who act like Ember is too hard. You may also notice that the build time takes around 8 - 10 seconds. This only occurs the first time. Subsequent builds are near instant.

This might go without saying, but that terminal window needs to be running to keep serving stuff, so make another one at the same location to input further commands.

T> You should really install the Chrome addon called Ember Inspector. It does a remarkably good job of debugging Ember apps, showing what all the bits are doing, displaying model data, deprecation warnings, etc. All further discussion in this book assumes you have it installed, because you're clearly a smart person who makes good decisions.

If you go to the URL that `ember server` gave you, you'll see Ember's default install app, featuring an adorable hamster. The first step to customising this requires a file that *used to* exist, but now inexplicably doesn't. This is a sort of base template file. The root, base, home, etc, of an Ember app is called `application`. We would like to have a base application template to put our nav and stuff in. We can make one easily.

~~~~~~~~
ember generate template application
~~~~~~~~

Now would be a pretty good time to make sure whatever editor you use is set up with the new project, or to open the directory, or whatever. Note that while editors often have functionality to make and manage files we shouldn't be needing those. That said, if you have an editor or IDE that has a command line feel free to use that. PHPStorm, Webstorm and Visual Studio Code all definitely do.

That file will be generated instantly, building nearly as quickly. It will also stop the application working, and make it a white screen. Ignore that. We've replaced the base template with an empty file, and we'll fix that now. If you go to `apps/templates` in your editor, you'll see it there now - `application.hbs`. A .hbs file is a handlebars template file. Not too dissimilar to Laravel's Blade. Much like blade, an empty root template with no sections or yields results in a screen that redefines "minimalism". What it needs is an `{{outlet}}` , so just type that in and save it. This is functionally similar to Blade's `@yield`. Add a H1 tag, and whatever markup you like, save, and we'll get on with it. You'll probably notice that Ember rebuilds everything automatically on your file change, and updates the browser accordingly. Wizards. If you can still see your `ember server` tab you will be able to see what it's building, too. That build process even gives you a heads-up about Javascript standards errors, which can often be very useful.

# Routes in Ember

The core thing to know about Ember is that it's all about the routes. Everything is build around the route you use, the actual request string. A Route in Ember is a specific object dedicated to handling a given URL pattern.  This simplifies Ember greatly - the current URL is the current state of the app, and can be rebuilt or reloaded or shared without issue. Back and next buttons, sharing and bookmarks all work perfectly fine.

That route-centric nature leads to a core difference between Laravel and Ember. The "route" is so central to Ember that the Route object is the equivalent to a Laravel controller, handling data access and templating. There **are** controllers in Ember, but they're mostly data decorators for the view, and they're largely deprecated now. Just for clarity (and it's not by any means a rule) we're just going to ignore controllers. Just bear in mind that the equivalent job of a Laravel Controller in Ember is the Route.

## Building our first route

We're going to start off with a really basic route. We want an about-us page, because it's apparently mandatory and it gives us a nice static page. The process of this is trivially simple. Ember CLI as well as scaffolding an application can also generate pieces of that application. This is not only something you can do but something you definitely should. Generating them like this is easier and faster in every way, and helps ensure things stay within Ember's happy conventions.

~~~~~~~~
ember generate route about-us
~~~~~~~~

You'll see that run through a few things, generating the files we need. If you open `app/router.js` you'll also see if you have a look that the router has been updated to add this new route. The main things added are a pair - the template and the route. 

T> You don't actually have to type `generate`, just typing `ember g` will do the same thing with less tapping. We were trying to be explicit, but from now on `ember g` will be used.

If you edit the new `apps/templates/about-us.hbs` you'll see that it's just a blank file. Throw a `<h2>About Us</h2>` at the top. Feel free to put in some lorem ipsum text so you can feel like a real designer, and we'll get on with it. You should also make sure you delete the `{{outlet}}`. We're not going to be putting any sub-routes in here or anything.

Going to that route at `http://localhost:4200/about-us` will show us exactly what we would expect to see.

A look at `apps/routes/about-us.js` shows us some pretty standard Ember ES6 boilerplate. More complex routes can have things like the model, actions and properties set in here, but our route is static HTML, so we don't really need any of that. In fact... delete it. Not the content. The whole `about-us.js` file. Seriously, do it. If you take another look at the page, you'll see that nothing's changed. Apparently routes aren't so important after all!

What's happening here is one of the great strengths of Ember. It has a strong philosophy of "Convention over Configuration". A lot of people take that to mean that Ember follows a strict set of rules. But a better way to think of it as mutual trust. If Ember's conventions are followed, it behaves with logical and reasonable defaults. In this case, a route is needed, and in fact it's so much needed that if not found, Ember will build one itself, identical to the default one from the generator. This is a **very good thing**, and it means you can simply remove files that don't do anything.

# Starting with Models

## A more useful Route

Very few routes are going to be that static. If you're using an SPA to build entirely static content you need to have a good long think about what you're doing with your life. We're going to now use the same process to build a second route.

~~~~~~~~
ember g route todo
~~~~~~~~

## Adding a model

This route is going to list all the todo items, so it's going to be much less static, and will need actual data, which is a core responsibiility of the Route. This just means adding a model hook to the existing boilerplate for your todo route.

~~~~~~~~~
// app/todo/route.js
export default Ember.Route.extend({
	model(){
		return [
			{id: 1, checked: false, text: 'Buy milk'},
			{id: 2, checked: false, text: 'Buy bread'},
			{id: 3, checked: false, text: 'Bring back Firefly'},
			{id: 4, checked: false, text: 'Conquer planet'}
		];
	}
});
~~~~~~~~~

W> Note that the code used in Ember objects always starts with a line of `import Ember from 'ember';`. We're not showing that in these examples, but it will be part of the code generated. It is not shown in these examples **purely to save space** and is definitely required for the code to function.

This data is now part of the route, and accessible in its templates, etc. This is obviously a simplified example. You would rarely hardcode data like this. A more common approach would be to use Ember Data models, which is kind of like the equivalent of an Eloquent model, forming an ORM for API access. Most particularly this abstracts away persistence, which we're not goihng to do here so we'll look at it more later.

If you're paying attention, you'll notice that the Route class contains the model data, but nothing at all seems to explicitly state the **template**. The location and name of the template is implied by conventions of name and structure of routes. In this case, the `app/routes/todo.js` route **must** be calling an `app/templates/todo.hbs` template. That's the convention. And of course, there we'll find it, so open it up.
You'll notice that the Route class contains the model data, but nothing at all seems to explicitly state the template. The location and structure of the template is implied by conventions of name and structure of routes. In this case, the `app/routes/todo.js` route **must** be calling an `app/templates/todo.hbs` template. That's the convention. And of course, there we'll find it, so open it up.

# Working with Templates

## Looping over the model

Looping over model data is nice and easy. Ember (like Blade or any other template system) has systems for looping over data. 

~~~~~~~~
<h2>My Items</h2>

<ul>
{{#each model as |item|}}
	<li>{{item.text}}</li>
{{/each}}
</ul>

{{outlet}}
~~~~~~~~

If the `|item|` is throwing you, now would be a great time to point out that just `item` used to work, but this newer syntax has some  benefit that is a bit irrelevant here, specifically to do with maintaining object scope when passing data into components. In short, it's how you have to do it.

Speaking of which, you should keep the `{{outlet}}` there too, at the bottom. We **will** be pulling content into this.

If you go back to the browser and put in `http://localhost:4200/todo/` you'll see that it does exactly what it should.

## Adding some links

It's at about this point that the staggering ugliness of what we're working on is starting to bug us. We can fix that now, starting as ever with usability issues. No one is ever going to type in your correct route urls, so let's make some actual proper links. Obviously you could just write `<a href="todo">`, but you'd lose all your SPAness, and that wouldn't be good. Ember has a nice helper for that, the `link-to` helper. 

We can provide a number of arguments to this thing, but the basic usage is a single argument to link to a route. If we edit the `apps/templates/application.hbs` file again we can put the following in and have a nice clean set of links for our application.

~~~~~~~~
<ul>
    <li>{{#link-to 'index'}}Home{{/link-to}}</li>
    <li>{{#link-to 'about-us'}}About Us{{/link-to}}</li>
    <li>{{#link-to 'todo'}}ToDo List{{/link-to}}</li>
</ul>


{{outlet}}
~~~~~~~~

## Understanding Outlets

Clicking between these is now handled as a transition inside the app. You'll note that the URL changes, but the interface doesn't really move around, as only the content of the `{{outlet}}` is changing. It's hard to really tell on such a simple site.

The outlet in Ember is very much like Laravel's `@yield` functionality, pulling in a sub-template. Unlike Laravel, which only needs to build the structure up once, Ember outlets are highly dynamic. They invariably have their contents changed on the fly. Any template that is rendering a sub-template needs to have an outlet there to take that. To put it another way, every route needs an outlet to go into. Our `about-us` route (and anything else on that level) goes into the application template's outlet. 

For now all of our routes are a flat structure. The only place they can or should render into is that one outlet. That will change soon.

# Testing in Ember

## How to run your tests

The simplest way to run your tests is to go to `http://localhost:4200/tests`. This will show a page with all of your tests on it. There are two possibilities at this point. If you've been largely ignoring me, and doing things at your own pace or however you want, everything will be fine, all tests green. If you actually listened and were obedient and well-behaved you now have at least one major error you need to fix. There's a life lesson in there.

The error is pretty simple. When we generated the routes earlier, EmberCLI also generated test stubs along with them. The tests are pretty trivial, they just tests that the JavaScript is valid and present. However, if you recall from earlier, we actually deleted the `about-us` route. It's no longer present. We can get rid of that error by simply deleting the `tests/unit/routes/about-us.js` file. There's no point testing code that doesn't exist. With that file gone, it should just test green.

This is the easiest way to test, but it's not the best. The best is to use EmberCLI. We can run the tests by simply running the command `ember test`. There's a fair chance that will get an error, too. It will say something along the lines of "Unable to find PhantomJS". Phantom is a "headless browser". It lets JavaScript execute in a command line, with no interface or display, and shows the results of the page tests, all run in memory. It's not exactly a default install. On a Mac at least it's easy to set up. `brew install phantomjs`

With that in place, `ember test` should happily display successful output.

## How to write tests

For the most part, Ember will generate the tests for you, or at least a test stub. This is a good starting point and saves you from having to do too much work. You also get the benefit that the intial tests in the stub are jslint tests, so if you violate any important JavaScript style rules it will get picked up.

# Making it look less awful

If you have functioning eyes you'll probably be moderately unhappy with the current aesthetic. We don't want to put too much effort into layout because it's out of scope of this book, but we want to get a nice clean look. 

## Installing Bootstrap and Font Awesome

The simplest way to do this is to implement Bootstrap. Bootstrap is available as an Ember Add-on, which is a good way to learn how to use these. The process is simple thanks to EmberCLI: `ember install ember-bootstrap`.

This will handle all the NPM stuff and Bower stuff, and add in any CSS or javascript files that are required by the addon. Just because I know we're going to use it anyway, let's throw some Font Awesome icons in there as well. Enter `ember install ember-font-awesome` and that one will do the same stuff.

T> Installing a new addon is one of the few things Ember server can't quite get its pretty little head around. It doesn't have access to the new files that are added while it's running. Just kill it (control + c, and yes, even on a Mac) and type `ember server` again and it will come back up in under a second.

To show how easy these addons are to use, we'll just do some more setup to make things look better. Open up `apps/templates/application.hbs` and wrap all of the contents of that in a bootstrap container div. 

~~~~~~~~
<div class="container">
// everything that was already here
</div>
~~~~~~~~

That's really all there is to it. The page will now have your title in a better font and with Bootstrap and Font Awesome ready to go, no gulpfile or build process, and you don't even have to include the CSS or javscript, that's already done for you. How far you take the Bootstrap layout is entirely up to you, but we're going to go with very minimal layout here because otherwise the markup gets bulky.

One thing we will do is "fix" the nav with large slabs of Bootstrap boilerplate first to replace all our simple, semantic code.

~~~~~~~~
<nav class="navbar navbar-default">
<ul class="nav navbar-nav">
    <li>{{#link-to 'index'}}Home{{/link-to}}</li>
    <li>{{#link-to 'about-us'}}About Us{{/link-to}}</li>
    <li>{{#link-to 'todo'}}ToDo List{{/link-to}}</li>
</ul>
</nav>
~~~~~~~~

Now it looks and functions like a real Bootstrap nav. With one exception. If you click around, you'll notice that the link changes slightly, but not like a full active link in Bootstrap should be. There's a reason for this - Ember is adding a class to the currently active link, `class="active"`. But Bootstrap expects that code on the `li`, not the `a` tag. There are a bunch of solutions to this, most of which are kind of hacky. The cleanest and easiest is another addon. `ember install ember-cli-active-link-wrapper`.

Installing this lets you replace the `li`, **not the link-to** with an active-aware version.

~~~~~~~~
{{#active-link}}{{#link-to 'index'}}Home{{/link-to}}{{/active-link}}
// and the other two
~~~~~~~~

Click around and the problem is fixed. Nice and simple.

# Nested Routes

## How to show a single item

As well as showing a list, we want to be able to view, and more particularly edit, a single item. The best way to do this is to use nested routes. This means that our Todo route will have a number of options - notably `show`, `edit`, and `new`. Before we get started on that, we need to make sure the parent template, our todo template, is ready. If we open that up (`apps/templates/todo.hbs`) You can see our listing of each todo item. What we need to do is make sure there's an `{{outlet}}` somewhere on this template, or any sub-routes we generate will have nothing to render into. If you don't see one there it's because you replaced it before when adding the foreach loop. If you just pasted the foreach loop above the outlet you should be good to go, but either way, just make sure it's there. Not having an outlet is a common cause of confusion when nesting things.

## Generating a nested route and the Ember Router

Generating a nested route is not really harder than generating any other. `ember generate route todo/show --path=:id` will get the job done handily. This also sets the path option in the route, which is worth a look at now.

If you open the router file, located at `app/router.js` you'll see a fairly familiar structure. This is appreciably similar in structure to the Laravel router, and obviously has the same goals. Some stuff isn't relevant to Ember, such as the method type, so specifying the method isn't meaningful.

All the generator work we've been doing has been also added into here automatically, so we haven't really needed to touch it, but it's good to have a look. The todo route is obviously different to the others, now being a nested route. Inside that the show route has a slightly different syntax as well, with a property object on it containing the path. The `:id` in there is much the same as Laravel's `{id}`, but the first part of it is implied from the parent route, so the whole route is `todo/123` rather than just `123`. That object, and specifically the path part of it, is implied in all routes. You could write our about route as `this.route('about-us', {path: 'about-us'});` if you wanted, but in the case of route paths that exactly match the route name it's implied. It's common for Ember to have these sensible defaults to make things more easy to read.

Rather than typing this URL in to check it, we're going to link to it properly. Edit your `app/templates/todo.hbs` file and go to the loop and add some links with the link-to helpers. The third second argument to the link-to helper, which we haven't used yet, is to pass in the object you're transitioning to. We can look look like this. I'll add some Bootstrap markup at the same time.

## More advanced link-to

Rather than typing this URL in to check it, we're going to link to it properly. Edit your `app/templates/todo.hbs` file and go to the loop and add some links with the link-to helpers. The second argument to the link-to helper, which we haven't used yet, is to pass in the object you're transitioning to. We can look look like this. I'll add some Bootstrap markup at the same time.

~~~~~~~~
<ul class="list-group">
{{#each model as |item|}}
	<li class="list-group-item">
        {{#link-to 'todo.show' item}}{{item.text}}{{/link-to}}
    </li>
{{/each}}
</ul>
~~~~~~~~

We have a template now as part of this generation, and it should be at `app/todo/show.hbs`. All we really need is some basic layout in this and we'll be good to go. Note that the model for a single todo will be a todo item, rather than the collection we used in the parent route.

## The template for a single item

We have a template now as part of this generation, and it should be at `app/todo/show.hbs`. All we really need is some basic layout in this and we'll be good to go. Note that the model for a single todo will be a todo item, rather than the collection we used in the parent route.

~~~~~~~~
<!-- app/todo/show.hbs -->
<div class="container">
	<div class="row">
		<div class="col-md-2">Text:</div>
		<div class="col-md-10">{{model.text}}</div>
	</div>
	<div class="row">
		<div class="col-md-2">Status:</div>
		<div class="col-md-10">{{model.checked}}</div>
	</div>
</div>
~~~~~~~~

Now you can go to the application, and click through to the Todo page, then click on any of the individual items to view its details.

## The single item route's model

This **seems** like it's done now, but if you reload this page you can see that it's actually only part of the way there. When Ember transitions from the Todos route to the show route it's passed in the object to use as the model. That means it doesn't have to run its own model hook. When it runs the route from scratch (like when we reload) it does have to. The fact that we haven't actually made that model hook is causing a bit of a problem there. 

It's important to remember that Ember is Route based. It's vitally important that all the routes work, and work on their own terms. So we'll need to provide a model hook for the todo.show route as well. In this case what we want to do is pretty simple. We **could** just dump in the same JavaScript array as the parent route, search it and return the correct object. But what we really want to do is get that array directly from the parent. Thankfully, Ember provides a nice simple way to do that.

Note that in this case we need to pass the parameters into the model hook. That wasn't necessary in the listing, because it didn't take any parameters.

~~~~~~~~~
// app/todo/show.js
export default Ember.Route.extend({
	model(params){
		let items = this.modelFor('todo');
		return items.find(function(item){
			return +params.id === item.id;
		});
	}
});

// alternatively shorter form ES6
return this.modelFor('todo')
    .find(item => +params.id === item.id);
~~~~~~~~~ 

If the `+params.id` part is confusing, it's an unusual but standard syntax. This isn't Ember, it's just a JavaScript unary operator.

T> If you look at the docs for link-to you'll see that it shows the third option as the id, which would make you think you pass in todo.id instead of the whole todo object. Either will work, but they work slightly differently. Passing in the id makes the show route run its own model hook, whereas passing in the object overrides it. In this app it's not noticeably different, but in many larger applications that show route model hook will run an API request. This would make passing in the model significantly faster and cleaner.

# Editing

We're going to start off by editing our existing items. There's a reason for that - it doesn't involve us managing the addition or removal of records, which we'll deal with separately.

## Another nested route - edit

What we need is another route, for a new todo item. `ember generate route todo/edit --path=:id/edit`.

If we have another look at our router after doing that we'll notice that the new route is **not** nested inside the show route, even though it might look like it from the URL. The path and the nesting absolutely do not have to be identical. How you structure the nesting should be based not on relationships between the **data**, but on relationships within the **interface**. The show and edit route are siblings, and from an interface point of view we want the edit form to replace display, not sit inside it.

This is a key for Ember that took me a while to really **get**. You should be thinking of all of this as the structure required for your interface - not the structure you require for your data. If the interface is nested, nest the routes. If they're not... don't. The relationship between data types, etc, is irrelevant. It's the relationship between the interface elements that really matters.

The `edit` route needs another model hook, which is the exact same code as the `show` model hook, so just grab that and paste it into the routes file, which in this case is located at `app/routes/todo/edit.js`. 

## The Input Helper

Much like links, inputs are an important part of an Ember app, as they are where user changes happen. As such, they have a special helper. As well as the obvious properties, such as `class`, the input helper critically takes a value property. That value is the model property being edited or created. The `app/templates/todo/edit.hbs` file should look very much like the following.

~~~~~~~~
<!-- app/todo/edit.hbs -->
<h3 class="no-top-margin">Update Todo Item</h3>

<div class="form-group">
    <label for="text">Text</label>
    {{input value=model.text class="form-control"}}
</div>
<div class="form-group">
    <button class="btn btn-info"{{action "update" model}}>{{fa-icon "cloud-upload"}} Update</button>
</div>
~~~~~~~~

Again, we'll update the todo loop to provide a link to this new edit route, as well as add some Bootstrap and Font Awesome magic to the interface. The `{{action "update" model}}` part of this is an action helper, telling Ember to run the update function on click (the default), and passing in the model at that time.

~~~~~~~~
<ul class="list-group">
{{#each model as |item|}}
    <li class="list-group-item">
    {{#link-to 'todo.show' item}}{{item.text}}{{/link-to}}
    {{#link-to 'todo.edit' item}}
        {{fa-icon "pencil" class="pull-right edit-link"}}
    {{/link-to}}
    </li>
{{/each}}
</ul>
~~~~~~~~

T> Note the simplicity of the implementation of Font Awesome, thanks to the add-on we installed earlier.

If you edit the details, you'll notice that as you change the details in the field, you also directly change the actual list-item. This is something called "Two-way binding". Two-way binding is a mixed blessing that looks great in a demo, but can cause state conflicts in a larger application. We'll deal with that in our larger application. You'll also notice that when you hit the "Update" button things go very badly wrong. The error says that there is nothing to handle the "update" action, and this is entirely accurate.

## Actions

Actions in Ember can be handled on a controller (as mentioned before) but in this case we'll handle it on the route, the edit route, specifically. If you open that file at `app/routes/todo/edit.js` you'll see where we already have the model hook. We need to add an actions object to that route, containing an update function. 

~~~~~~~~
//app/routes/todo/edit.js
export default Ember.Route.extend({
	model(params){
		let items = this.modelFor('todo');
		return items.find(function(item){
			return +params.id === item.id;
		});
	},
    actions: {
        update(item){
            alert('saved');
        }
    }
});
~~~~~~~~

You'll hopefully have noticed that parameter, the item parameter. That's being passed through in the action helper above, and contains the model for this route. All of the editing of the object has been done in the model  by editing it, so in this case there's nothing to actually save. The model has already changed. In a real application this would be where those changes were persisted, saving the data back to the API, etc. 

# Creating a new item

The new item is slightly more complex because it affects the collection as well as an entire item. It's not much more so, and certainly starts off the same.

## As always - generate another route

~~~~~~~~
ember generate route todo/new
~~~~~~~~

We can grab the exact same form details, copying the entire of `edit.hbs` and pasting it into `new.hbs`, then just changing the word "Update" where it appears to "Create". Don't forget to change the action! That will be `create`, this time course.

Before we forget, we need to add a button to create a new item, and we need to put it into `app/templates/todo.hbs`. Under the list you can just put the following line to get a nicely styled button.

~~~~~~~~
{{#link-to 'todo.new' class="btn btn-info"}}
    {{fa-icon "plus-circle"}} Add item
{{/link-to}}
~~~~~~~~

The content of the new route is slightly less obvious than some of the others. Obviously we're going to need an action because we need to save it. But less obviously we're going to also need a model. It wouldn't seem like we do, because we're creating a model here. But creating a model up front gives us something to edit. In fact we need a model backing the new template in order to give the template something to hook into, so that when the form is being edited it's making changes to something. 

In theory what we need to return from the model hook is a blank Ember Object. In practise, Ember will wrap anything returned from the model hook in its own voodoo, so we literally just need to return an empty javascript object.

We also need an action, and this needs to do just a little more than the edit route. In particular it needs to add the new item to our listing. Conveniently, the listing is actually the model for our parent route, so we can add it on there.

The `new.js` file will contain:

~~~~~~~~
export default Ember.Route.extend({
  model(){
    return {};
  },
  actions: {
    create(item){

      let collection = this.modelFor('todo');

      collection.pushObject({
          id: collection.length,
          text: item.text,
          checked: false
      });
    }
  }
});
~~~~~~~~

This is probably the most JavaScript we've seen so far in one go. But it should still be easy to follow. A lot of that should be easy to follow. The model as we said before is just an empty object so that our forms have a model backing them. Then there's an actions object, containing a single create function, which is passed the previously mentioned now-not-so-empty model. Inside that is where newer things are happening.

The collection of all the different todo items is the model for the todo route, so we grab that. It's simply the easiest thing to do, and to be honest it most clearly reflects the intent here. This is an Ember Collection object, so we use the `pushObject` method to add a new item to it. We could just use the standard array push, but pushObject respects all the watchers and magic of Ember, making it immediately just as usable as any other item in our collection. Again, it would be typical to persist this new item back to the server as well, but a step not being taken by our demo application.

# Checking an item

There's only one real requirement left. A todo list that can't check off items is in poor shape. We need to add that functionality. The first step is to figure out whose responsibility this is. It might be initially tempting to assume this is the responsibility of the edit route, but remember, from an interface point of view we really just want to handle this directly in the todos listing view, not go somewhere else to do it. So what we need to do is put an action in the todo route.

## A simple action

This action is surprisingly small. All we really want to do is toggle on and off a particular property on a given item that's passed into the action. To do this we just need to add the action object with this function to the todo route that already has the model.

~~~~~~~
// rest of the object
    actions: {
        checkItem(item){
            Ember.set(item, 'checked', !Ember.get(item, 'checked'));
        }
    }
});
~~~~~~~

This takes in the item, and then uses `Ember.set` to update a property - checked, in this case. Using Ember.set instead of something like `item.checked = true` allows the change to propagate all through the app, keeping everything properly in sync. If you try and just set the property directly Ember Inspector will spit up warnings at you. The `Ember.get` plays a similar role, returning a safe version of the value of the property on that object, and the ! just causes it to invert. Again, this would be the point where we would be saving back to an API.

T> This could actually be written quite a bit more simply as `item.toggleProperty('checked');`, which is a shortcut for a lot of the above.

## Connecting up the action in the template

The only other thing to do is add a checkbox with the action and a bit of styling on the list item. We'll start by modifying the todo list template again. This is now our complete todo.hbs, including some Bootstrap layout and all the additional buttons and classes.

~~~~~~~
<!-- app/tempates/todo.hbs -->
<h2>Current Items</h2>

<div class="row">
<div class="col-md-4">
<ul class="list-group">
{{#each model as |item|}}
    <li class="list-group-item 
        {{if item.checked "checked" "unchecked"}}">
        <span class="check-icon" {{action 'checkItem' item}}>
            {{fa-icon (if item.checked "check-square-o" "square-o")}}
        </span>

        {{#link-to 'todo.show' item}}{{item.text}}{{/link-to}}
        {{#link-to 'todo.edit' item}}
            {{fa-icon "pencil" class="pull-right edit-link"}}
        {{/link-to}}
    </li>
{{/each}}
</ul>
    {{#link-to 'todo.new' class="btn btn-info"}}
        {{fa-icon "plus-circle"}} Add item
    {{/link-to}}
</div>
<div class="col-md-4">
    {{outlet}}
</div>
</div>
~~~~~~~

The new code is mostly in the span that we've thrown an action on and put an icon inside. A conditional `if` as the second parameter tells it whether to have the icon checked or unchecked. Similar code exists above and tells the class whether to be checked or unchecked so our styling will work.

## Handling CSS 

Styling isn't something we've looked into yet, so now is the time. Open up `app/styles/app.css` and you'll have an empty stylesheet to work with. Adding any styling into there will be immediately built and put into the app.css used by the application. We're going to dump in some css mostly just for look. What exactly it does should be readily apparent.

~~~~~~~~
.check-icon {
  display: inline-block;
  width: 15px;
}

li.checked {
  text-decoration: line-through;
}

li .edit-link {
  display: none;
}

li:hover .edit-link {
  display: inline-block;
}
~~~~~~~~

Most of it is just polish so that we don't see the edit icons unless we mouseover the list item, and the second rule is to make checked items have a strikethrough effect.

This doesn't just have to be CSS. If you're wanting to use Sass, and you should, it's trivial to set up. Just install `ember install ember-cli-sass` and you can just rename `app/styles/app.css` to `app/styles/app.scss`, or create a new one. 

That's it. We're done. We've built an Ember app. With the knowledge of how to do it and given a reasonable expectation of the details of the layout, this whole thing could be done in about 20 minutes. Sure, it doesn't do a whole lot. But it does let you see clearly that Ember does **not** have to be hard. Its 
